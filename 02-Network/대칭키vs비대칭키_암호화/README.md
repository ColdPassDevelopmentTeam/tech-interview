# 🔐 암호화 기초 (Encryption Overview)

정보보안에서 **암호화(Encryption)** 는 데이터를 읽을 수 없는 형태로 변환하여 **기밀성(Confidentiality)** 을 유지하는 핵심 기술이다.  
데이터가 외부에 유출되더라도, 암호화되어 있다면 의미 없는 문자로 보이게 된다.

---

## 📘 암호화의 기본 개념

암호화 과정은 다음 네 단계로 이루어진다:

1. **평문 (Plaintext)** — 사람이 읽을 수 있는 원본 데이터  
2. **암호문 (Ciphertext)** — 암호화 과정을 거쳐 변환된 데이터  
3. **복호화 (Decryption)** — 암호문을 다시 평문으로 되돌리는 과정  
4. **부인방지 (Non-repudiation)** — 행위자가 자신이 한 행위를 부인하지 못하도록 하는 보안 속성  
   - 예: 디지털 서명, 블록체인, 시스템 로그

---

## 🧭 암호화의 3대 목표 (CIA Triad)

| 보안 요소 | 설명 | 예시 |
|------------|------|------|
| **기밀성 (Confidentiality)** | 인가되지 않은 사용자는 정보에 접근할 수 없음 | HTTPS, VPN |
| **무결성 (Integrity)** | 데이터가 전송 중 변조되지 않았음을 보장 | 해시 검증 (SHA-256 등) |
| **인증 (Authentication)** | 사용자 또는 시스템의 정당성을 검증 | 로그인, 디지털 서명 |

> 💬 추가로, **부인방지 (Non-repudiation)** 는 행위자가 “안 했다”고 주장할 수 없도록 하는 속성으로, 디지털 서명과 PKI가 사용된다.

---

## ⚙️ 대칭키 암호화 (Symmetric Encryption)

### 개념
암호화와 복호화에 **같은 키**를 사용하는 방식  
→ 키가 유출되면 전체 시스템이 위험하지만, **연산이 매우 빠르다.**

| 항목 | 설명 |
|------|------|
| **장점** | 속도가 빠르고 구현이 간단함 |
| **단점** | 키를 안전하게 공유해야 함 |
| **대표 알고리즘** | AES, DES, 3DES, RC4, ChaCha20 |

---

### 🔸 AES (Advanced Encryption Standard)

AES는 128비트 블록 단위로 데이터를 암호화하며, 키 길이에 따라 **AES-128 / AES-192 / AES-256**으로 구분된다.

**과정 요약**
1. `SubBytes` — 각 바이트를 S-box를 통해 치환  
2. `ShiftRows` — 행 단위로 순환 이동  
3. `MixColumns` — 열 단위로 선형변환 수행  
4. `AddRoundKey` — 라운드 키를 XOR 연산  

**활용 분야**
- HTTPS 세션 암호화  
- VPN 트래픽 보호  
- 파일 암호화 (예: AES-256 ZIP)

---

### 🔹 블록 암호 운용 모드

| 모드 | 설명 | 주의점 |
|------|------|--------|
| **ECB** | 각 블록을 독립적으로 암호화 | ❌ 패턴이 그대로 노출되어 보안 취약 |
| **CBC** | 이전 블록의 암호문을 다음 블록에 XOR | IV 필수 |
| **CTR** | 카운터 값과 XOR → 병렬처리 가능 | Nonce 재사용 금지 |
| **GCM** | 암호화 + 인증 태그(무결성 보장) | AEAD 권장 |

✅ **실무 권장**: AES-GCM 또는 ChaCha20-Poly1305

---

## 🧩 비대칭키 암호화 (Asymmetric Encryption)

### 개념
**공개키 (Public Key)** 와 **개인키 (Private Key)** 를 분리하여 사용하는 암호 방식  
→ 공개키로 암호화하고, 개인키로 복호화함.

| 항목 | 설명 |
|------|------|
| **장점** | 키 분배가 안전하며 부인방지가 가능 |
| **단점** | 연산 속도가 느림 |
| **대표 알고리즘** | RSA, ECC, ElGamal |

---

### 🔸 RSA (Rivest–Shamir–Adleman)

**과정 요약**
1. 두 소수 `p, q`를 선택하고 `n = p × q` 계산  
2. 오일러 피함수 `φ(n) = (p-1)(q-1)` 계산  
3. `e`와 `d`를 선택 (서로 역원 관계)  
   - `e × d ≡ 1 (mod φ(n))`  
4. 공개키 `(n, e)` / 개인키 `(n, d)` 생성  

**활용 예시**
- SSL/TLS 인증서  
- 이메일 암호화 (PGP)  
- 전자서명 시스템

> 💡 실제 HTTPS는 RSA로 세션키를 교환하고, AES로 데이터를 암호화하는 “**하이브리드 암호화**”를 사용한다.

---

### 🔹 ECC (Elliptic Curve Cryptography)

- 타원곡선 수학을 이용해 RSA보다 **짧은 키로 동일한 보안성 확보**
- **ECDH**(키 교환), **ECDSA**(서명), **Ed25519**(고속 서명)

| 비교 | RSA-2048 | ECC-256 |
|------|-----------|---------|
| 보안 수준 | 동일 | 동일 |
| 키 길이 | 길다 | 짧다 |
| 속도 | 느림 | 빠름 |

---

## 🔄 하이브리드 암호화 (Hybrid Encryption)

현대의 대부분의 보안 통신(TLS, VPN, 메신저)은  
**대칭키 + 비대칭키 + 무결성 + 인증**을 결합해 사용한다.

**구조**
1. 비대칭키로 세션키 교환  
2. 대칭키로 본문 데이터 암호화  
3. HMAC 또는 GCM으로 무결성 보장  
4. 인증서 서명으로 신원·부인방지 달성  

---

## 🧠 무결성 (Integrity)

### 📘 개념

**무결성**은 데이터가 **전송·저장 중 변조되지 않았음을 보장**하는 속성이다.  
즉, 누군가가 메시지를 바꾸거나 위조하더라도 이를 **탐지할 수 있어야 한다.**

예: 송신자가 “송금액 10,000원”을 보냈는데  
누군가 “100,000원”으로 바꿔치기했다면, 수신자는 그 변조를 알아야 한다.

---

### 🔹 무결성을 보장하는 기술

#### 1. 해시(Hash)
- 입력을 고정 길이의 요약값으로 변환  
- 미세한 변화에도 전혀 다른 결과  
- 대표: SHA-256, SHA-512  

```python
import hashlib
print(hashlib.sha256(b"hello").hexdigest())

# 🧩 MAC (Message Authentication Code)

## 📘 개념
**MAC(Message Authentication Code)** 는  
메시지의 **무결성(Integrity)** 과 **인증(Authentication)** 을 동시에 보장하는 기술이다.  
즉, 송신된 데이터가 **변조되지 않았고**, **정당한 발신자에게서 왔음을** 검증하기 위한 방법이다.

---

## ⚙️ 동작 원리

1. 송신자와 수신자가 **공유 비밀키(K)** 를 미리 알고 있다.  
2. 송신자는 메시지(M)에 대해 MAC 함수를 적용해 **태그(tag)** 를 생성한다.  
   - `tag = MAC_K(M)`  
3. 송신자는 (M, tag)를 수신자에게 전송한다.  
4. 수신자는 같은 키(K)로 `MAC_K(M')` 을 다시 계산하고,  
   - 수신한 `tag` 와 동일하다면 메시지가 **변조되지 않음**을 확인할 수 있다.



## 🔐 수식 표현
생성: T = MAC_K(M)
검증: MAC_K(M') == T ?


- 일치하면 ✅ **정상 메시지**
- 불일치하면 ❌ **변조 또는 위조된 데이터**

---

## 💡 특징 요약

| 항목 | 설명 |
|------|------|
| **보장 속성** | 무결성 + 인증 |
| **기반 알고리즘** | 대칭키 기반 |
| **대표 구현** | HMAC, CMAC, GMAC |
| **비교대상** | 해시는 무결성만, MAC은 인증도 가능 |

---

## 🔹 HMAC (Hash-based MAC)

**HMAC** 은 해시함수(SHA-256 등)에 키를 결합하여 MAC을 생성하는 방식이다.  
대부분의 보안 프로토콜(HTTPS, JWT, API 서명 등)에서 사용된다.

```python
import hmac, hashlib

msg = b"Transfer:10000"
key = b"secret_key"

tag = hmac.new(key, msg, hashlib.sha256).hexdigest()
print(tag)
# 결과 예시: b1946ac92492d2347c6235b4d2611184


해시 함수만 쓸 때보다 재연 공격(replay attack) 에 강함
키 유출 시에는 보호 불가하므로 KMS/HSM 관리 필요



# 🧾 부인방지 (Non-repudiation)

## 📘 개념
**부인방지(Non-repudiation)** 는 정보보안의 핵심 속성 중 하나로,  
**어떤 행위(데이터 전송, 서명, 명령 등)가 실제로 발생했음을 증명하고,  
그 행위자가 이후에 이를 부인하지 못하게 만드는 기술적·관리적 방법**을 말한다.

즉, “내가 보낸 게 아니다”, “나는 승인하지 않았다” 같은 주장을 기술적으로 방지하는 것이다.

---

## 🎯 부인방지의 목적
- **송신자 부인 방지**: 메시지를 보낸 사람이 나중에 “보내지 않았다”고 주장하지 못하도록 함  
- **수신자 부인 방지**: 수신자가 “받지 않았다”고 주장하지 못하도록 함  
- **행위 증명**: 거래, 명령, 서명 등 모든 전자적 행위의 책임 추적 가능성 확보

---

## ⚙️ 달성 방법

| 기술 | 역할 |
|------|------|
| **디지털 서명 (Digital Signature)** | 개인키로 메시지를 서명 → 공개키로 검증 가능 |
| **공개키 기반 구조 (PKI)** | 인증기관(CA)을 통해 공개키의 신뢰성과 소유자 신원 보장 |
| **타임스탬프(TSA)** | 전자 문서나 서명이 특정 시점에 존재했음을 증명 |
| **감사로그(Audit Log)** | 행위 이력 및 변경 내역을 추적하고 삭제 불가하게 기록 |
| **블록체인 Anchoring** | 로그나 해시를 블록체인에 고정해 위조 불가능하게 만듦 |

---

## 🧩 디지털 서명을 이용한 부인방지

1. 송신자는 개인키(Private Key)로 메시지 해시에 서명한다.  
2. 수신자는 송신자의 공개키(Public Key)로 서명 검증을 수행한다.  
3. 서명이 유효하면 메시지가 **정당한 발신자**에게서 왔음을 보장하고,  
   **해시 일치**를 통해 **무결성**도 함께 검증할 수 있다.

> 💡 서명된 메시지는 이후 제3자(법원, 감사기관 등)도 검증 가능하므로 부인할 수 없다.

---

## 🔐 주요 구성 요소

| 구성 요소 | 설명 |
|------------|------|
| **개인키(Private Key)** | 서명을 생성하는 비밀키 (소유자만 사용 가능) |
| **공개키(Public Key)** | 서명을 검증하는 공개된 키 |
| **인증서(Certificate)** | 공개키와 사용자의 신원을 연결하는 문서 |
| **CA (Certification Authority)** | 공개키가 실제로 누구의 것인지 보증하는 기관 |
| **TSA (Time Stamping Authority)** | 전자문서의 생성 시점을 증명하는 제3자 기관 |

---

## 🧱 실무 적용 예시

| 분야 | 적용 방식 |
|------|------------|
| **전자계약 / 전자서명** | 개인키로 계약서 서명 + 타임스탬프 첨부 |
| **전자결제** | 거래 요청 및 승인 내역에 디지털 서명 적용 |
| **블록체인 거래** | 개인키 기반 서명으로 거래 기록 증명 |
| **정부 행정시스템** | 공문서 발송·접수 기록에 부인방지 서명 저장 |

---

## ⚠️ 주의사항

- **개인키 탈취 시 부인방지 무력화**  
  → HSM(하드웨어 보안 모듈) 또는 KMS(Key Management Service)로 보호 필요  
- **서버 대리서명 구조**는 실제 사용자 부인방지 약화 가능  
  → 개인 단말 내 서명 또는 2FA 연동 권장  
- **타임스탬프 미사용 시 시점 증명 불가**  
  → 법적 효력 확보를 위해 TSA 기반 시간정보 필수  
- **로그 위변조 방지**  
  → 해시 체이닝, WORM 스토리지, 블록체인 연동 사용 권장

---

## ✅ 정리

| 항목 | 설명 |
|------|------|
| **목적** | 송신자·수신자의 행위 부인 방지 |
| **핵심 기술** | 디지털 서명 + 인증서(PKI) + 타임스탬프 |
| **보완 기술** | 감사로그, 블록체인 Anchoring |
| **법적 효력 확보 요건** | 전자서명법, 기록 보존 정책 준수 |
| **실무 권장 구성** | 개인키 보호(HSM) + TSA 타임스탬프 + 감사로그 연동 |

---

> 📄 **요약**  
> 부인방지는 단순한 암호화로 달성되지 않는다.  
> 반드시 **디지털 서명**, **신원 인증(PKI)**, **시간 증명(TSA)**, **로그 보존**이 함께 이뤄져야 완전한 기술적 신뢰성을 확보할 수 있다.
