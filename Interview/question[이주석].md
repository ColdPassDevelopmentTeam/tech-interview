## 질문 답변모음
### 인가와 인증의 차이? 
- 인증은 이 사람이 누구인가WHO?를 확인하는 것이고,  
- 인가는 이 사람은 무엇을 할수있는가what?을 확인하는것입니다.
#### 꼬리질문1: 그렇다면 인증의 방법으로는 무엇이 있나요?
- 가장 단순한 방식으로는 요청마다 인증 관련 데이터를 함께 전송하는 방식이 있으며, 이때 쿠키를 활용할 수 있습니다.
- 인증 방식은 크게 세션 방식과 토큰 방식으로 나눌 수 있습니다.
  - 세션 방식은 서버에 사용자 정보를 저장해두고 클라이언트는 세션 ID만을 가지고 다니는 방식입니다.
  - 토큰 방식은 서버가 사용자 정보를 저장하지 않고, 서명된 토큰을 클라이언트에게 전달하며 이후 요청 시 해당 토큰을 통해 검증하는 방식입니다.
#### 꼬리질문2: 토큰방식과 세션방식을 비교하면?
- 토큰방식은 무상태성을 유지할 수 있다는 장점이 있습니다.  (stateless) 즉, 아무리 많은 사용자가 연결을 해도 서버가 저장할 필요가없으므로 확장성이 좋습니다.  
세션은 서버에 상태를 저장해야하기 때문에 확장성이 떨어집니다
- 보안측면에서 토큰은 토큰 탈취시 보안이 매우 취약합니다.  
세션방식은 서버에 사용자 정보를 저장하기 때문에 토큰방식에 비해 보안이 더 좋습니다.
- 또한 토큰의 크기가 세션ID에 비해 크기 때문에 네트워크 비용이 토큰이 더 큽니다.
  
### TCP와 UDP의 차이점
- TCP는 연결지향형 프로토콜로, 데이터의 신뢰성 있는 전
송을 보장합니다. 데이터가 손실되거나 순서가 바뀌었을 때 재전송 및 재정렬 기능을 제공합니다.
- UDP는 비연결형 프로토콜로, 데이터의 신뢰성을 보장하지 않습니다. 데이터가 손실되거나 순서가 바뀌어도 재전송하지 않으며, 빠른 전송이 필요한 실시간 애플리케이션에 적합합니다.
#### 꼬리질문: TCP의 3-way Handshake 과정을 설명해 주세요.
- 클라이언트가 서버에 연결 요청을 위해 SYN 패킷을 보냅니다.
- 서버는 클라이언트의 요청을 수락하고, SYN-ACK 패킷을 클라이언트에게 보냅니다.
- 클라이언트는 서버의 응답을 확인하고, ACK 패킷을 서버에 보냅니다.
- 이로써 연결이 성립되어 데이터 전송이 시작됩니다.  

#### 꼬리질문2: TCP의 혼잡 제어 메커니즘에 대해 설명해 주세요.
- TCP의 혼잡 제어는 네트워크 혼잡을 감지하고 이를 완화하기 위한 메커니즘입니다. 이를 위해 슬로우 스타트, 혼잡 회피, 빠른 회복, 빠른 재전송을 사용합니다.
- 슬로우 스타트는 초기 혼잡 윈도우 크기를 작게 설정하고, ACK를 받을 때마다 윈도우 크기를 지수적으로 증가시킵니다.
- 혼잡 회피는 혼잡 윈도우 크기를 선형적으로 증가시켜 네트워크 혼잡을 완화합니다.
- 빠른 재전송은 중복 ACK(3개)를 감지하면 손실된 패킷을 즉시 재전송합니다.
- 빠른 회복은 손실된 패킷이 재전송된 후에도 혼잡 윈도우 크기를 감소시키지 않고 유지합니다.
> 그림 그리면서 설명하는게 효과적임.(지수증가 ,선형증가, 절반감소하는 그래프)

### www.naver.com의 IP주소를 찾는 과정을 설명해 주세요.(DNS 조회 과정)(변종으로 OSI 7계층 엮어서 질문도 가능)
- 사용자가 웹브라우저에 도메인 네임(예: www.naver.com)을 입력하면, 브라우저는 DNS 캐시(hosts도 설명하면 굿)를 확인합니다.
- 캐시에 해당 도메인의 IP 주소가 없으면, 운영체제에 설정된 DNS 서버(일반적으로 ISP나 공용 DNS 서버)로 질의합니다.
- DNS 서버가 해당 도메인의 IP 주소를 알고 있으면, 이를 반환합니다. 만약 모른다면, DNS 서버는 루트 DNS 서버에 질의하여 시작합니다.
- 루트 DNS 서버는 최상위 도메인(TLD) 서버(com)의 위치를 알려줍니다.
- 이후 TLD(com) 서버에 질의하여 도메인을 관리하는 권한 있는 네임서버의 위치를 얻습니다.
- 마지막으로, 권한 있는 네임서버에 질의하여 도메인의 실제 IP 주소를 받아옵니다.
- 이 IP 주소는 브라우저로 반환되어, 사용자는 해당 웹사이트에 접속할 수 있게 됩니다.
#### 꼬리질문: 재귀 조회와 반복 조회의 차이점은?
- 재귀 조회는 클라이언트가 DNS 서버에 질의할 때, DNS 서버가 최종 답변을 찾을 때까지 다른  DNS 서버에 질의를 대신 수행하는 방식입니다.
- 반복 조회는 클라이언트가 DNS 서버에 질의할 때, DNS 서버가 최종 답변을 찾지 못하면, 다음에 질의할 DNS 서버의 주소를 클라이언트에게 반환하는 방식입니다. 클라이언트가 직접 다음 DNS 서버에 질의해야 합니다.

### 프로세스와 쓰레드의 차이점
프로 세스는 운영체제에서 할당하는 자원의 단위로, 각각 독립된 메모리 공간과 자원을 가지고 실행됩니다.
쓰레드는 프로세스 내에서 실행되는 작업의 단위로, 같은 프로세스 내의 다른 쓰레드와 메모리 공간을 공유합니다. (자원의단위, 실행흐름의 단위 / 메모리공유여부 중요)

#### 꼬리질문 1: 멀티스레드 vs 멀티프로세스
- 멀티스레드는 메모리 공유로 인해 컨텍스트 스위칭 오버헤드가 적고, 자원 사용이 효율적입니다. 그러나 하나의 쓰레드가 크래시하면 전체 프로세스에 영향을 미칠 수 있습니다.
- 멀티프로세스는 각 프로세스가 독립적으로 실행되므로 안정성이 높습니다. 하나의 프로세스가 실패해도 다른 프로세스에 영향을 미치지 않습니다. 그러나 메모리 사용량이 많고, 컨텍스트 스위칭 오버헤드가 큽니다.
  
#### 꼬리질문 2: context switching을 설명하고 오버헤드를 설명해주세요
- 컨텍스트 스위칭은 운영체제가 한 쓰레드에서 다른 쓰레드로 전환하는 과정입니다. 이 과정에서는 현재 실행 중인 프로세스의 상태(레지스터 값, 프로그램 카운터 등)를 저장하고, 새로 실행할 프로세스의 상태를 복원합니다. 
> 쓰레드 대신 프로세스로 설명해도 ok
- 이 떄문에 3가지 오버헤드가 발생합니다.  
위에서 설명했듯이 상태를 저장하고 복원하는 데 시간이 소요되기 때문이고   
또한 어떤 프로세스로 전환할지 선택해야하기에 프로세스 스케쥴링의 비용이 있으며,  
마지막으로, TLB(Translation Lookaside Buffer)도 플러시되어야 할 수 있어 캐시미스로 인한 추가적인 지연이 발생할 수 있습니다(3). 
> 상태저장할때 PCB도 언급하면 좋음, TLB대신 캐시라고만 언급해도 ok

### 배열과 연결리스트의 차이점
- 배열은 메모리 상에 연속적으로 할당된 데이터 구조로, 인덱스를 통해 빠른 접근이 가능합니다. 그러나 크기가 고정되어 있어 삽입과 삭제가 비효율적일 수 있습니다.
- 연결리스트는 각 노드가 포인터로 연결된 데이터 구조로, 동적으로 크기를 조절할 수 있으며 삽입과 삭제가 용이합니다. 그러나 인덱스를 통한 접근이 불가능하여 탐색 속도가 느립니다.
> 시간복잡도로 설명하면 더 좋다 (배열: 접근 O(1), 삽입/삭제 O(n) / 연결리스트: 접근 O(n), 삽입/삭제 O(1))
#### 꼬리질문: 힙을 구현할때 배열과 연결리스트중 어떤걸 쓰는게 좋을까요?
- 힙은 완전 이진 트리의 특성을 가지므로, 배열을 사용하는 것이 일반적입니다. 배열을 사용하면 부모-자식 노드 간의 인덱스 계산이 간단해지고, 스왑도 간단하며, 메모리 사용이 효율적입니다. 
- 연결리스트를 사용하면 포인터 관리로 인해 오버헤드(스왑이 자주일어나므로)가 발생하고, 트리 구조를 유지하기 어려워집니다.
#### 꼬리질문: 시간복잡도는무엇인가요
- 시간복잡도는 알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기에 대한 함수로 표현한 것입니다. 일반적으로 빅오 표기법을 사용하여 최악의 경우 성능을 나타냅니다. 최악을 기준으로 하는 이유는, 알고리즘이 처리할 수 있는 최대 입력 크기에 대해 성능을 예측하고 보장하기 위함입니다.


### 트랜잭션의 ACID를  설명해 주세요.
- Atomicity(원자성)  
트랜잭션은 모두 수행되거나 모두 수행되지 않아야 합니다.
중간에 실패하면 모든 변경 사항이 rollback됩니다.

- Consistency(일관성)  
트랜잭션 수행 전·후의 데이터는 항상 데이터베이스 규칙을 만족해야 합니다.

- Isolation(고립성)  
트랜잭션은 서로 독립적으로 수행되어야 하며, 동시에 실행되더라도 결과가 순차 실행과 동일해야 합니다.

- Durability(지속성)  
트랜잭션이 성공적으로 완료되면 결과는 영구히 저장되어 장애가 발생해도 유지됩니다.

#### 꼬리질문: 트랜잭션 격리 수준에는 어떤 것들이 있나요?
- READ UNCOMMITTED (커밋되지 않은 읽기)  
다른 트랜잭션에서 커밋되지 않은 데이터(Dirty Data) 도 읽을 수 있습니다.
성능은 가장 좋으나, 일관성이 매우 낮아 거의 사용하지 않습니다.  
Dirty Read,	Unrepeatable Read, Phantom Data Read 모두 발생합니다

- READ COMMITTED (커밋된 읽기)
커밋된 데이터만 읽을 수 있습니다.
Unrepeatable Read, Phantom Data Read이 발생 가능합니다

- REPEATABLE READ (반복 가능 읽기)  
한 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 값이 동일하게 유지됩니다.
Phantom Data Read만 발생 가능합니다

- SERIALIZABLE (직렬화)  
트랜잭션을 직렬적으로 수행한 것과 동일한 효과입니다.
동시성이 낮아지고 성능이 저하되기 때문에 잘 사용되지 않습니다.
Dirty Read	Unrepeatable Read	Phantom Read 모두 발생하지 않습니다

### 인덱스에대해 설명해주세요
인덱스는 검색 속도를 높이기 위한 자료구조입니다.  
책의 목차처럼 특정 컬럼을 기준으로 빠르게 탐색할 수 있게 해줍니다.  
다만, 추가적인 저장공간이 들고 성능면에서도 인덱스는 INSERT, UPDATE, DELETE같은 데이터 변경 시 추가적인 인덱스 수정이 필요하므로 쓰기 성능이 저하될 수 있습니다.    
따라서 조회를 빠르게 해야 하는 컬럼에만 인덱스를 생성하는 것이 좋습니다.
#### 꼬리질문: 인덱스는 어떤 자료구조로 구현되나요?
- 일반적으로 B-트리(Balanced Tree) 또는 B+트리 자료구조로 구현됩니다.
- B-트리는 균형 트리 구조로, 모든 리프 노드가 동일한 깊이에 있어 탐색 시간이 일정합니다.
- 또한, DB 인덱스는 메모리가 아닌 디스크 페이지 단위로 저장됩니다. B-트리는 한 노드가 많은 key를 저장할 수 있으므로
트리의 높이를 낮게 유지할 수 있고, 디스크 접근 횟수를 최소화할 수 있습니다.
- B+트리는 B-트리의 변형으로, 리프 노드에만 데이터가 저장되고, 내부 노드는 인덱스 역할만 수행하여 범위 검색에 유리합니다
리프 노드는 서로 연결 리스트로 연결되어 있어 순차 접근이 효율적입니다.
> IO의 느린 속도와 B트리의 낮은 높이로인한 적은 접근 횟수를 연결시키면 best
#### 꼬리질문: hash보다 B-트리 인덱스를 주로 사용하는 이유는?
- B-트리 인덱스는 범위 검색에 유리하며, 정렬된 데이터에 대한 탐색이 효율적입니다.  
- 반면, 해시 인덱스는 정확한 값 검색에만 적합하며, 범위 검색이나 정렬된 데이터 탐색에는 부적합합니다.  


### ARP에대해 설명해주세요
- ARP(Address Resolution Protocol)는 네트워크 계층(IP 주소)에서 데이터 링크 계층(MAC 주소)로의 주소 변환을 담당하는 프로토콜입니다. 컴퓨터가 로컬 네트워크 내의 다른 장치와 통신하려면 최종적으로 MAC 주소를 알아야 하기 때문에 ARP가 필요합니다.
0. 먼저 ARP Cache 테이블에서 해당 IP 주소에 대한 MAC 주소가 있는지 확인합니다.
1. 캐시가 없다면 ARP 요청 패킷을 브로드캐스트로 전송하여 해당 IP 주소를 가진 장치가 자신의 MAC 주소를 응답하도록 합니다.
2. 해당 IP 주소를 가진 장치는 ARP 응답 패킷을 유니캐스트로 보내 자신의 MAC 주소를 알려줍니다.
3. 요청한 장치는 이 MAC 주소를 ARP 캐시에 저장하고, 이후 통신에 사용합니다.
#### 꼬리질문: ARP 스푸핑이 무엇인가요?
- ARP 스푸핑은 공격자가 네트워크 내에서 ARP 프로토콜을 악용하여 자신의 MAC 주소를 다른 장치의 IP 주소에 매핑시키는 공격입니다.  
- 예를 들어, 공격자가 게이트웨이의 IP 주소에 자신의 MAC 주소를 매핑시키면, 네트워크 내의 다른 장치들은 게이트웨이로 가는 트래픽을 공격자에게 보내게 됩니다. 


