## **웹 브라우저에 `www.naver.com`을 입력했을 때 어떤 일이 일어나는지 설명해주세요.(네트워크)**

사용자가 주소창에 `www.naver.com`을 입력하고 엔터를 누르면, 브라우저는 최종적으로 IP 주소를 알아내 해당 서버와 TCP 통신을 시작하고, HTTP(S) 프로토콜을 통해 웹 페이지 리소스를 받아와 렌더링하는 과정을 거칩니다. 이 전체 과정을 단계별로 나누면 다음과 같습니다.

1.  **URL 파싱 및 DNS 조회 (주소 탐색):**
    -   브라우저는 입력된 URL(`https://www.naver.com`)을 해석하고, 도메인 이름인 `www.naver.com`에 해당하는 IP 주소를 찾기 시작합니다.
    -   **DNS 조회 과정:** 브라우저 캐시 → OS 캐시(hosts 파일 등) → 라우터 캐시 → ISP의 DNS 서버 순서로 IP 주소를 확인합니다. 
    
    여기에 없으면, ISP의 DNS 서버가 Root DNS 서버부터 TLD(`.com`) DNS 서버, Authoritative DNS 서버(`naver.com`) 순으로 재귀적으로(Recursive) 쿼리를 보내 최종 IP 주소를 얻어옵니다.

2.  **서버와 TCP 연결 수립:**
    -   DNS 조회를 통해 얻은 IP 주소(예: `223.130.195.95`)와 포트 번호(HTTPS는 443)를 이용해 서버와 TCP 연결을 맺습니다.
    -   이 과정에서 **3-Way Handshake** (`SYN` -> `SYN+ACK` -> `ACK`)를 통해 신뢰성 있는 연결을 수립합니다.

3.  **HTTPS 통신 (TLS/SSL Handshake):**
    -   TCP 연결 위에서 HTTPS 통신을 위한 암호화 채널을 설정합니다.
    -   **TLS/SSL Handshake** 과정을 통해 서버의 신원을 인증서(Certificate)로 확인하고, 앞으로 사용할 대칭키를 안전하게 교환합니다.

4.  **HTTP 요청 및 응답:**
    -   암호화된 채널을 통해 브라우저는 서버에 HTTP `GET / HTTP/1.1`과 같은 요청 메시지를 보냅니다. 헤더에는 브라우저 정보, 쿠키 등이 포함됩니다.
    -   서버(Nginx 등)는 요청을 받아 처리하고, 그 결과를 담은 HTTP 응답 메시지(상태 코드, HTML 문서 등)를 브라우저에 전달합니다.

5.  **브라우저 렌더링:**
    -   브라우저는 서버로부터 받은 HTML 문서를 파싱하여 DOM(Document Object Model) 트리를 구축합니다.
    -   HTML 파싱 중 `<link>`, `<style>` 태그를 만나면 CSS를 파싱하여 CSSOM(CSS Object Model) 트리를 만듭니다.
    -   DOM과 CSSOM을 결합하여 **렌더 트리(Render Tree)** 를 생성합니다.
    -   이후 **레이아웃(Layout/Reflow)** 과정을 통해 각 요소의 위치와 크기를 계산하고, **페인트(Paint)** 과정을 통해 화면에 픽셀을 채워넣습니다. `<script>` 태그를 만나면 DOM 생성을 중단하고 자바스크립트를 먼저 실행합니다.

---

### **꼬리질문 1: DNS가 무엇이며, 어떤 계층에서 동작하나요? DNS 조회 과정에 대해 더 자세히 설명해주세요.**

**DNS(Domain Name System)** 는 사람이 읽기 쉬운 도메인 이름(예: `www.naver.com`)을 컴퓨터가 통신에 사용하는 IP 주소(예: `223.130.195.95`)로 변환해주는 분산 데이터베이스 시스템입니다.

*   **동작 계층:** DNS는 **애플리케이션 계층(OSI 7계층)** 프로토콜입니다. IP 주소를 찾기 위해 UDP(주로 사용) 또는 TCP(512바이트 초과 데이터, 영역 전송 시) 포트 53번을 사용합니다.
*   **상세 조회 과정 (Recursive Query):**
    1.  **Local Cache 확인:** 브라우저 → OS → 라우터 순으로 로컬 캐시에 해당 도메인의 IP 정보가 있는지 확인합니다.
    2.  **Recursive DNS Server (Resolver)에 요청:** 캐시에 정보가 없으면, 통신사(ISP)가 제공하는 DNS 서버(리졸버)에 요청을 보냅니다.
    3.  **Iterative Query 시작:** 리졸버는 **Root DNS 서버**에 `www.naver.com`의 IP를 묻습니다.
    4.  Root 서버는 `.com`을 관리하는 **TLD(Top-Level Domain) DNS 서버**의 주소를 알려줍니다.
    5.  리졸버는 TLD 서버에 다시 `www.naver.com`의 IP를 묻습니다.
    6.  TLD 서버는 `naver.com`을 관리하는 **Authoritative DNS 서버**의 주소를 알려줍니다.
    7.  리졸버는 최종적으로 Authoritative 서버에 `www.naver.com`의 IP를 묻고, 실제 IP 주소를 응답받습니다.
    8.  리졸버는 이 IP 주소를 OS에 전달하고, 지정된 시간(TTL) 동안 캐싱합니다.

---

### **꼬리질문 2: HTTPS는 HTTP와 어떻게 다른가요? SSL/TLS 핸드셰이크 과정에 대해 설명해주세요.**

**HTTPS(HTTP Secure)** 는 HTTP의 보안이 강화된 버전입니다. 가장 큰 차이점은 **암호화** 여부입니다.

*   **HTTP:** 평문(Plain Text) 통신을 하므로 제3자가 네트워크 패킷을 가로채면(스니핑) 내용을 그대로 볼 수 있습니다.
*   **HTTPS:** **SSL/TLS(Secure Sockets Layer/Transport Layer Security)** 프로토콜을 이용해 모든 통신 내용을 암호화합니다. 이를 통해 **기밀성(Confidentiality)**, **무결성(Integrity)**, **인증(Authentication)** 을 보장합니다.

**SSL/TLS 핸드셰이크 과정 (TLS 1.2 기준):**

1.  **Client Hello:** 클라이언트(브라우저)가 서버에 랜덤 데이터, 지원하는 암호화 스위트(Cipher Suites) 목록 등을 보내며 연결을 요청합니다.
2.  **Server Hello:** 서버는 클라이언트의 암호화 스위트 중 하나를 선택하고, 자신의 랜덤 데이터와 **서버 인증서(Public Key 포함)** 를 클라이언트에 보냅니다.
3.  **Client Key Exchange:**
    -   클라이언트는 서버가 보낸 인증서가 신뢰할 수 있는 CA(Certificate Authority)로부터 발급되었는지 확인합니다.
    -   신뢰할 수 있다면, 클라이언트는 앞으로 통신에 사용할 **대칭키(세션 키)의 재료가 될 `pre-master secret`** 을 생성합니다.
    -   이 `pre-master secret`을 서버의 공개키로 암호화하여 서버에 전송합니다.
4.  **Server Decryption & Session Key Generation:**
    -   서버는 자신의 개인키로 암호화된 `pre-master secret`을 복호화합니다.
    -   이제 클라이언트와 서버 양쪽 모두 `Client Hello`, `Server Hello`의 랜덤 데이터와 `pre-master secret`을 조합하여 동일한 **대칭키(세션 키)** 를 생성합니다.
5.  **Finished:** 양측은 생성된 세션 키로 암호화된 "Finished" 메시지를 교환하며 핸드셰이크 과정을 완료합니다. 이후 모든 통신은 이 세션 키를 이용해 대칭키 암호화 방식으로 이루어집니다.

---

### **꼬리질문 3: 브라우저 렌더링 과정(Critical Rendering Path)에 대해 설명하고, 이를 최적화할 수 있는 방법에 대해 아는대로 이야기해주세요.**

**CRP(Critical Rendering Path)** 는 브라우저가 HTML, CSS, JavaScript를 화면에 픽셀로 변환하는 일련의 단계를 의미합니다. 이 경로를 최적화하는 것은 초기 렌더링 속도를 높여 사용자 경험(UX)을 개선하는 데 핵심적입니다.

**최적화 방법:**

1.  **리소스 로딩 최적화:**
    -   **CSS:** CSS는 렌더링 차단(Render-Blocking) 리소스입니다. `<head>` 태그 안에서 `<link>`를 사용해 최대한 빨리 로드해야 합니다. 미디어 쿼리(`media="print"`)를 사용해 불필요한 CSS 로드를 막을 수 있습니다.
    -   **JavaScript:** JS는 파싱 차단(Parser-Blocking) 리소스입니다. DOM 생성을 막기 때문에 `<body>` 태그 최하단에 배치하거나, `defer` 또는 `async` 속성을 사용해 비동기적으로 로드합니다.
        -   `async`: 다운로드와 HTML 파싱이 병렬로 진행되며, 다운로드 완료 즉시 실행됩니다. (순서 보장 X)
        -   `defer`: 다운로드와 HTML 파싱이 병렬로 진행되며, HTML 파싱이 끝난 후 순서대로 실행됩니다. (순서 보장 O)

2.  **렌더 트리 생성 최적화:**
    -   **DOM/CSSOM 생성 최소화:** 불필요한 HTML 태그나 복잡한 CSS 선택자(`ul > li > a`) 사용을 줄여 파싱 속도를 높입니다.

3.  **레이아웃 및 페인트 최적화:**
    -   **리플로우(Reflow) 및 리페인트(Repaint) 최소화:** JS로 DOM을 조작하면 레이아웃 계산(리플로우)과 다시 그리기(리페인트)가 발생하여 성능을 저하시킵니다.
        -   `transform`, `opacity` 같이 레이아웃에 영향을 주지 않는 속성을 사용해 애니메이션을 구현합니다.
        -   DOM 변경을 한번에 묶어서 처리하거나, `display: none`으로 숨긴 상태에서 변경 후 다시 보이게 합니다.
    -   **리소스 크기 축소:** HTML, CSS, JS 파일을 압축(Minify)하고, 이미지는 WebP와 같은 최신 포맷을 사용하며 적절한 크기로 제공합니다. CDN을 활용해 리소스 로딩 속도를 개선합니다.

## **2. RESTful API에 대해 설명하고, 좋은 REST API를 설계하기 위한 원칙은 무엇이 있을까요?(네트워크)**

**REST(Representational State Transfer)** 는 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하는 소프트웨어 아키텍처 스타일입니다. REST의 원칙을 따라 설계된 API를 **RESTful API**라고 부릅니다. 핵심은 **자원(Resource)**, **행위(Verb)**, **표현(Representation)**으로 구성되며, HTTP URI를 통해 자원을 명시하고 HTTP Method(GET, POST, PUT, PATCH, DELETE)를 통해 해당 자원에 대한 행위를 정의합니다.

**좋은 REST API 설계 원칙:**

1.  **자원 중심의 URI 설계 (명사 사용):**
    -   URI는 동사가 아닌 **명사**로 자원을 표현해야 합니다.
    -   (Bad) `/getUsers/1`, `/deleteUser/1`
    -   (Good) `GET /users/1`, `DELETE /users/1`
    -   자원의 계층 관계는 슬래시(`/`)로 표현합니다. (예: `/users/1/posts`)

2.  **적절한 HTTP Method 사용:**
    -   **GET:** 자원 조회 (멱등성 O)
    -   **POST:** 자원 생성 (멱등성 X)
    -   **PUT:** 자원 전체 교체 (멱등성 O)
    -   **PATCH:** 자원 일부 수정 (멱등성 X, 보통 멱등하게 구현)
    -   **DELETE:** 자원 삭제 (멱등성 O)

3.  **상태 코드(Status Code)의 명확한 사용:**
    -   요청의 결과를 명확히 알려주어야 합니다.
    -   `200 OK`, `201 Created`, `204 No Content`
    -   `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`
    -   `500 Internal Server Error`

4.  **일관성 있는 응답 데이터 포맷:**
    -   성공/실패 시의 응답 구조를 일관되게 유지하고, 에러 발생 시 원인을 파악할 수 있는 메시지(에러 코드, 설명)를 포함해야 합니다.
    -   페이징, 필터링, 정렬 등 복잡한 조회 기능을 위한 쿼리 파라미터 규칙을 제공합니다. (예: `?limit=10&offset=20&sort=createdAt:desc`)

5.  **HATEOAS (Hypermedia as the Engine of Application State):**
    -   응답 데이터에 관련된 다른 URI를 포함시켜, 클라이언트가 다음 행동을 할 수 있도록 유도합니다. 이를 통해 클라이언트와 서버 간의 결합도를 낮출 수 있습니다.
    -   예: `/users/1` 조회 시, `{"name": "...", "links": [{"rel": "posts", "href": "/users/1/posts"}]}` 와 같이 관련 링크를 제공합니다.

---

### **꼬리질문 1: PUT과 PATCH 메서드의 차이점은 무엇인가요? 각각 어떤 상황에서 사용해야 할까요?**

**PUT**과 **PATCH** 는 모두 자원을 수정하는 데 사용되지만, **수정의 범위**에서 근본적인 차이가 있습니다.

*   **PUT (전체 교체):** 자원의 **모든 속성** 을 클라이언트가 보낸 데이터로 완전히 교체합니다. 만약 요청에 특정 필드가 누락되면, 해당 필드는 `null`이나 초기값으로 설정됩니다. 따라서 PUT 요청은 **멱등성(Idempotent)** 을 가집니다. (여러 번 보내도 결과는 동일)
    -   **사용 상황:** 자원의 모든 정보를 한번에 업데이트해야 할 때 사용합니다. 예를 들어, 회원 정보 수정 페이지에서 모든 필드를 채워 제출하는 경우입니다.

*   **PATCH (부분 수정):** 자원의 **일부 속성**만을 변경합니다. 요청에 포함된 필드만 수정되고, 나머지 필드는 기존 값을 유지합니다. 따라서 PATCH는 이론적으로 멱등하지 않을 수 있습니다. (예: `visits` 필드를 1 증가시키는 PATCH 요청은 보낼 때마다 결과가 달라짐)
    -   **사용 상황:** 자원의 특정 필드 하나만 변경하고 싶을 때 사용합니다. 예를 들어, 게시물의 제목만 수정하거나, 상품의 재고만 변경하는 경우입니다. 네트워크 대역폭을 아낄 수 있고 더 효율적입니다.

---

### **꼬리질문 2: API 버전 관리는 어떻게 할 수 있을까요? URL에 버전을 명시하는 것 외에 다른 방법이 있다면 소개해주세요.**

API는 한번 배포되면 클라이언트가 의존하기 때문에, 변경이 필요할 때 하위 호환성을 유지하기 위해 버전 관리가 필수적입니다.

1.  **URL에 버전 명시 (가장 흔한 방식):**
    -   `https://api.example.com/v1/users`
    -   **장점:** 직관적이고, 브라우저에서 바로 테스트하기 편리합니다.
    -   **단점:** 버전이 올라갈 때마다 URI가 변경됩니다. (REST 원칙에 따르면 URI는 자원을 표현해야 하므로, 버전 정보가 들어가는 것은 좋지 않다는 의견도 있습니다.)

2.  **쿼리 파라미터에 버전 명시:**
    -   `https://api.example.com/users?version=1`
    -   **장점:** URI가 변경되지 않아 깔끔합니다.
    -   **단점:** 버전별로 라우팅하기가 번거로울 수 있습니다.

3.  **HTTP 헤더에 버전 명시 (Accept Header):**
    -   `Accept: application/vnd.example.api.v1+json`
    -   **장점:** URI가 순수하게 자원만 표현하므로 가장 RESTful한 방식이라고 평가받습니다.
    -   **단점:** 요청을 보내기가 번거롭고, 직관성이 떨어집니다. 브라우저에서 테스트하기 어렵습니다.

**실무적 관점:** 대부분의 기업에서는 직관성과 관리의 용이성 때문에 **URL에 버전을 명시하는 방식(1번)** 을 가장 많이 채택합니다.

---

### **꼬리질문 3: REST API에서 인증(Authentication)과 인가(Authorization)는 어떻게 구현할 수 있을까요? Spring Security 경험과 관련지어 설명해주세요.**

**인증(Authentication)** 은 사용자가 누구인지 확인하는 과정(로그인)이고, **인가(Authorization)** 는 인증된 사용자가 특정 자원에 접근할 권한이 있는지 확인하는 과정(권한 체크)입니다.

**Spring Security를 이용한 구현:**

1.  **인증 (Authentication):**
    -   **토큰 기반 인증 (JWT):** 현대적인 REST API에서는 상태를 저장하지 않는(Stateless) **JWT(JSON Web Token)** 방식을 주로 사용합니다.
    -   **로그인 과정:**
        1.  사용자가 ID/PW로 로그인 요청(`POST /api/login`)을 보냅니다.
        2.  `UsernamePasswordAuthenticationFilter`가 요청을 가로채 `AuthenticationManager`에 인증을 위임합니다.
        3.  `AuthenticationManager`는 `UserDetailsService`를 통해 DB에서 사용자 정보를 조회하고, `PasswordEncoder`로 비밀번호를 비교하여 인증을 수행합니다.
        4.  인증에 성공하면, **Access Token**과 **Refresh Token** 을 생성하여 사용자에게 반환합니다.

2.  **인가 (Authorization):**
    -   **요청 처리 과정:**
        1.  클라이언트는 이후의 모든 요청에 발급받은 Access Token을 **`Authorization` 헤더**에 담아 보냅니다. (예: `Authorization: Bearer <token>`)
        2.  `JwtAuthenticationFilter`와 같은 커스텀 필터가 요청 헤더에서 토큰을 추출하고 유효성을 검증합니다.
        3.  토큰이 유효하면, 토큰에 담긴 사용자 정보(ID, 권한 등)를 이용해 `Authentication` 객체를 생성하고 **`SecurityContextHolder`**에 저장합니다. `SecurityContextHolder`는 현재 스레드 내에서 인증 정보를 전역적으로 관리합니다.
        4.  이후 `FilterSecurityInterceptor`가 사용자의 권한을 확인하여 해당 API에 접근할 수 있는지 최종적으로 결정합니다.
    -   **권한 설정:** `@PreAuthorize("hasRole('ADMIN')")`나 `http.authorizeRequests().antMatchers("/api/admin/**").hasRole("ADMIN")` 와 같은 설정을 통해 특정 URL 패턴이나 메서드에 필요한 권한을 지정할 수 있습니다.

## **3. 프로세스와 스레드의 차이점에 대해 설명해주세요.(OS)**

**프로세스(Process)** 는 운영체제로부터 자원을 할당받는 **작업의 단위** 이며, **스레드(Thread)** 는 프로세스가 할당받은 자원을 이용하는 **실행의 단위**입니다.

*   **프로세스:**
    -   운영체제로부터 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받습니다.
    -   각 프로세스는 최소 하나 이상의 스레드(메인 스레드)를 가집니다.
    -   프로세스 간에는 자원을 공유하지 않기 때문에, 통신을 하려면 IPC(Inter-Process Communication)와 같은 복잡한 방법이 필요합니다.
    -   하나의 프로세스가 비정상 종료되어도 다른 프로세스에 영향을 주지 않습니다.

*   **스레드:**
    -   한 프로세스 내에서 동작하며, 프로세스의 **Heap, Data, Code 영역을 공유**합니다.
    -   각 스레드는 자신만의 **Stack**과 **Program Counter(PC)** 를 가집니다. (메서드 호출, 지역 변수 등은 독립적으로 관리)
    -   자원을 공유하기 때문에 스레드 간 통신이 간단하고 비용이 적게 듭니다.
    -   하나의 스레드에 문제가 생기면 전체 프로세스가 종료될 수 있습니다. (예: Unhandled Exception)

**비유:** 프로세스를 '공장', 스레드를 '일꾼'에 비유할 수 있습니다. 공장은 부지, 전기, 원자재(자원)를 할당받고, 일꾼들은 이 자원을 공유하며 각자 다른 작업(실행)을 수행합니다.

---

### **꼬리질문 1: 멀티스레드 환경에서 발생할 수 있는 문제점(예: 경쟁 상태, 교착 상태)은 무엇이며, 이를 어떻게 해결할 수 있을까요?**

1.  **경쟁 상태 (Race Condition):**
    -   **문제점:** 여러 스레드가 동시에 하나의 공유 자원(변수, 객체 등)에 접근하여 값을 변경하려고 할 때, 접근 순서에 따라 예상치 못한 결과가 발생하는 문제입니다. (예: `count++` 연산)
    -   **해결책 (동기화, Synchronization):**
        -   **`synchronized` 키워드:** 특정 코드 블록이나 메서드를 임계 영역(Critical Section)으로 지정하여, 한번에 하나의 스레드만 접근하도록 Lock을 겁니다.
        -   **`volatile` 키워드:** 변수에 대한 변경이 즉시 메인 메모리에 반영되도록 보장하여, 각 스레드가 항상 최신 값을 읽도록 합니다. (원자성은 보장하지 않음)
        -   **`java.util.concurrent.atomic` 패키지:** `AtomicInteger` 등 CAS(Compare-And-Swap) 알고리즘을 사용하는 원자적 연산을 지원하는 클래스를 사용합니다. `synchronized`보다 가볍고 효율적입니다.

2.  **교착 상태 (Deadlock):**
    -   **문제점:** 두 개 이상의 스레드가 서로 상대방이 점유하고 있는 자원을 무한정 기다리는 상태입니다.
    -   **발생 조건 (4가지 모두 충족 시):**
        1.  **상호 배제 (Mutual Exclusion):** 한 자원은 한번에 하나의 스레드만 사용 가능
        2.  **점유와 대기 (Hold and Wait):** 자원을 가진 상태에서 다른 자원을 기다림
        3.  **비선점 (No Preemption):** 다른 스레드의 자원을 강제로 뺏을 수 없음
        4.  **환형 대기 (Circular Wait):** 스레드들이 원형으로 서로의 자원을 기다림
    -   **해결책:**
        -   **자원 획득 순서 강제:** 모든 스레드가 항상 같은 순서로 Lock을 획득하도록 규칙을 정합니다. (환형 대기 조건 방지)
        -   **타임아웃 사용:** `Lock.tryLock(timeout)`을 사용해 일정 시간 동안 Lock을 얻지 못하면 작업을 포기하고 다른 처리를 하도록 합니다. (점유와 대기 조건 방지)
        -   교착 상태는 한번 발생하면 디버깅이 매우 어렵기 때문에, 설계 단계에서부터 발생 조건을 피하는 것이 가장 중요합니다.

---

### **꼬리질문 2: 자바에서 스레드를 생성하는 방법에는 어떤 것들이 있나요? Runnable과 Thread 클래스를 상속하는 것의 차이는 무엇인가요?**

자바에서 스레드를 생성하는 방법은 크게 두 가지입니다.

1.  **`Thread` 클래스 상속:**
    ```java
    class MyThread extends Thread {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    MyThread t = new MyThread();
    t.start();
    ```

2.  **`Runnable` 인터페이스 구현:**
    ```java
    class MyRunnable implements Runnable {
        public void run() {
            // 스레드가 수행할 작업
        }
    }
    Thread t = new Thread(new MyRunnable());
    t.start();
    ```

**차이점과 권장 방식:**

| 구분 | `Thread` 클래스 상속 | `Runnable` 인터페이스 구현 |
| --- | --- | --- |
| **상속** | 다른 클래스를 상속할 수 없음 (자바는 단일 상속만 허용) | 다른 클래스를 상속하면서 스레드 로직 구현 가능 |
| **결합도** | 스레드 로직과 `Thread` 클래스의 기능이 강하게 결합됨 | 스레드 로직(`Runnable`)과 스레드 자체(`Thread`)가 분리되어 유연함 |
| **재사용성** | 낮음 | 높음 (같은 `Runnable` 객체를 여러 스레드에서 재사용 가능) |

**결론적으로 `Runnable` 인터페이스를 구현하는 방식이 더 권장됩니다.** 객체지향적인 설계(관심사 분리)에 부합하며, 코드의 유연성과 재사용성을 높여주기 때문입니다. 람다 표현식을 사용하면 코드를 더 간결하게 작성할 수도 있습니다.

```java
Thread t = new Thread(() -> {
    // 스레드가 수행할 작업
});
t.start();
```

---

### **꼬리질문 3: 스레드 풀(Thread Pool)은 왜 사용하며, 사용했을 때의 장점은 무엇인가요?**

**스레드 풀** 은 미리 일정 개수의 스레드를 생성해두고, 필요할 때마다 이 스레드들을 가져다 쓰고 작업이 끝나면 다시 풀에 반납하는 방식입니다.

**사용 이유와 장점:**

1.  **성능 향상 및 자원 효율성:**
    -   스레드를 생성하고 파괴하는 과정은 생각보다 큰 오버헤드(메모리 할당, 컨텍스트 스위칭)를 유발합니다. 스레드 풀은 스레드를 재사용하므로 이 비용을 크게 줄일 수 있습니다.
    -   애플리케이션이 갑작스러운 요청 증가로 인해 무한정 스레드를 생성하는 것을 방지하여, 시스템이 다운되는 것을 막아줍니다.

2.  **안정적인 시스템 운영:**
    -   동시에 실행될 수 있는 스레드의 최대 개수를 제한하여 시스템의 CPU와 메모리 사용량을 예측 가능한 범위 내에서 안정적으로 관리할 수 있습니다.

3.  **효율적인 작업 관리:**
    -   `java.util.concurrent.ExecutorService`를 통해 스레드 풀을 쉽게 관리할 수 있습니다. 작업 큐, 스레드 개수 조절, 작업 취소 등 다양한 기능을 제공하여 개발자가 스레드 생명주기를 직접 관리하는 복잡함을 덜어줍니다.

**실무 적용:** 웹 서버(Tomcat 등)의 WAS는 클라이언트의 요청을 처리하기 위해 내부적으로 스레드 풀을 사용합니다. 스레드 풀의 크기를 적절하게 튜닝하는 것은 웹 애플리케이션의 성능 최적화에 매우 중요합니다.

## **4. 데이터베이스에서 인덱스를 사용하는 이유와 장단점에 대해 설명해주세요.(DB)**

**인덱스(Index)** 는 데이터베이스 테이블의 **검색(SELECT) 성능을 향상시키기 위한 자료구조**입니다. 책의 맨 뒤에 있는 '찾아보기'와 같은 역할을 합니다.

*   **사용 이유:** 인덱스가 없으면 특정 데이터를 찾기 위해 테이블 전체를 스캔해야 합니다(Full Table Scan). 하지만 인덱스를 사용하면 데이터가 정렬된 상태로 저장된 별도의 자료구조를 통해 원하는 데이터의 위치(주소)를 빠르게 찾아낼 수 있어 검색 속도가 비약적으로 향상됩니다.

**장점:**
*   **빠른 검색 속도:** `WHERE` 절이나 `JOIN` 작업의 성능을 크게 향상시킵니다.
*   **정렬 속도 향상:** `ORDER BY` 작업 시, 이미 정렬된 인덱스를 활용할 수 있어 추가적인 정렬 과정이 필요 없을 수 있습니다.
*   **UNIQUE 제약조건 강화:** Primary Key나 Unique 인덱스를 통해 데이터의 유일성을 보장할 수 있습니다.

**단점:**
*   **쓰기 성능 저하:** 데이터에 `INSERT`, `UPDATE`, `DELETE` 작업이 발생할 때마다 인덱스 테이블도 함께 수정되어야 하므로 쓰기 성능이 저하됩니다.
*   **추가 저장 공간 필요:** 인덱스는 원본 테이블과는 별도의 저장 공간을 차지합니다. (테이블 크기의 약 10% 내외)
*   **잘못된 사용 시 성능 저하:** 인덱스를 잘못 설계하면 오히려 사용되지 않거나(Unused Index), 옵티마이저가 잘못된 인덱스를 선택하여(Wrong Index) 성능이 더 나빠질 수 있습니다. 따라서 카디널리티(Cardinality, 중복도)가 높은 컬럼에 생성하는 것이 좋습니다.

---

### **꼬리질문 1: 인덱스의 자료구조로는 보통 어떤 것을 사용하나요? B-Tree와 B+Tree의 차이점에 대해 설명해주세요.**

인덱스의 자료구조로는 주로 **B-Tree(Balanced Tree)** 가 사용되며, 특히 InnoDB 스토리지 엔진을 사용하는 MySQL/MariaDB에서는 **B+Tree** 가 사용됩니다.

*   **B-Tree:**
    -   하나의 노드에 여러 개의 데이터가 들어갈 수 있는 균형 잡힌 트리 구조입니다.
    -   모든 노드(루트, 브랜치, 리프)에 `Key`와 `Data`를 함께 저장합니다. `Data`는 실제 데이터의 주소값(포인터)입니다.

*   **B+Tree:**
    -   B-Tree를 개선한 자료구조입니다.
    -   **리프 노드(Leaf Node)에만 `Key`와 `Data`를 저장**하고, 나머지 브랜치 노드에는 자식 노드를 찾아가기 위한 `Key`만 저장합니다.
    -   모든 리프 노드는 **연결 리스트(Linked List)** 형태로 서로 연결되어 있어, 범위 검색(Range Scan) 시 매우 효율적입니다.

**B-Tree 대비 B+Tree의 장점:**

1.  **향상된 범위 검색 성능:** 리프 노드들이 연결 리스트로 이어져 있어, 특정 범위의 데이터를 조회할 때 트리를 다시 탐색할 필요 없이 리프 노드의 연결 리스트를 순차적으로 따라가기만 하면 됩니다. (예: `WHERE age BETWEEN 20 AND 30`)
2.  **더 많은 키 저장 가능:** 브랜치 노드에 데이터 포인터를 저장하지 않으므로, 같은 크기의 노드에 더 많은 키를 저장할 수 있습니다. 이는 트리의 높이(height)를 낮추는 효과를 가져와, 결과적으로 디스크 I/O 횟수를 줄여 검색 성능을 향상시킵니다.

---

### **꼬리질문 2: 클러스터형 인덱스(Clustered Index)와 비클러스터형 인덱스(Non-Clustered Index)의 차이는 무엇인가요?**

1.  **클러스터형 인덱스 (Clustered Index):**
    -   **물리적 정렬:** 테이블의 데이터 자체가 인덱스의 키 값 순서대로 **물리적으로 정렬**되어 저장됩니다. 영어 사전을 생각하면 쉽습니다. (단어 순서대로 내용이 정렬됨)
    -   **테이블당 하나만 존재:** 물리적인 순서는 하나만 가능하므로, 테이블당 하나의 클러스터형 인덱스만 생성할 수 있습니다.
    -   **PK 제약조건:** Primary Key로 지정하면 해당 컬럼이 기본적으로 클러스터형 인덱스가 됩니다.
    -   **리프 노드:** 리프 노드가 곧 데이터 자체입니다.
    -   **장점:** 키 값 기반의 범위 검색 성능이 매우 뛰어납니다.
    -   **단점:** 데이터 입력/수정 시 물리적인 재정렬이 필요할 수 있어 쓰기 성능이 비클러스터형보다 불리할 수 있습니다.

2.  **비클러스터형 인덱스 (Non-Clustered Index / Secondary Index):**
    -   **별도의 인덱스 페이지:** 데이터는 물리적으로 정렬되지 않고, 인덱스 키 값만 정렬된 별도의 인덱스 페이지를 가집니다. 일반적인 책의 '찾아보기'와 같습니다.
    -   **테이블당 여러 개 존재:** 여러 개의 비클러스터형 인덱스를 생성할 수 있습니다.
    -   **리프 노드:** 리프 노드는 실제 데이터의 위치를 가리키는 포인터(클러스터형 인덱스의 키 값 또는 물리적 주소)를 가집니다.
    -   **장점:** 쓰기 성능이 클러스터형보다 유리합니다.
    -   **단점:** 데이터를 찾기 위해 인덱스 페이지를 먼저 탐색한 후, 다시 데이터 페이지로 이동해야 하므로 한번의 디스크 I/O가 더 발생할 수 있습니다.

---

### **꼬리질문 3: 실행 계획(Execution Plan)이 무엇인지 설명하고, 쿼리 성능을 최적화하기 위해 실행 계획을 어떻게 활용할 수 있을까요?**

**실행 계획** 은 데이터베이스 옵티마이저(Optimizer)가 사용자의 SQL 쿼리를 가장 효율적으로 실행하기 위해 수립한 **절차와 방법**입니다. `EXPLAIN` 키워드를 쿼리 앞에 붙여 확인할 수 있습니다.

실행 계획에는 다음과 같은 정보가 포함됩니다.
*   어떤 순서로 테이블에 접근할 것인가? (Join 순서)
*   각 테이블에 접근할 때 어떤 인덱스를 사용할 것인가? (Full Scan vs Index Scan)
*   어떤 조인 방식을 사용할 것인가? (Nested Loop Join, Hash Join 등)

**실행 계획 활용법 (쿼리 튜닝):**

1.  **Full Table Scan 확인:** `type` 컬럼이 `ALL`로 표시되면 테이블 전체를 스캔하고 있다는 의미이므로, 가장 먼저 확인해야 할 비효율 지점입니다. `WHERE` 절에 사용된 컬럼에 적절한 인덱스를 생성하여 `ref`, `range`, `index` 등으로 개선해야 합니다.

2.  **불필요한 인덱스 사용 확인:** `possible_keys`에는 사용할 수 있는 인덱스 목록이, `key`에는 옵티마이저가 실제로 선택한 인덱스가 표시됩니다. 만약 옵티마이저가 최적의 인덱스를 선택하지 못했다면, 인덱스 힌트(`USE INDEX`)를 사용하거나 쿼리 구조를 변경하여 유도할 수 있습니다.

3.  **조인 순서 및 방식 확인:** 조인 순서에 따라 성능이 크게 달라질 수 있습니다. 데이터가 적은 테이블을 먼저 읽는 것이 일반적으로 유리합니다.

4.  **`Extra` 컬럼 확인:** `Using filesort`, `Using temporary`와 같은 문구가 나타나면 주의해야 합니다.
    -   `Using filesort`: 인덱스를 사용하지 못하고 별도의 정렬 작업을 수행했다는 의미입니다. `ORDER BY` 절에 사용된 컬럼에 인덱스를 추가하는 것을 고려해야 합니다.
    -   `Using temporary`: 임시 테이블을 생성했다는 의미로, 성능 저하의 주된 원인입니다. 쿼리 로직 자체를 재검토해야 할 수 있습니다.

실행 계획을 분석하여 옵티마이저가 비효율적으로 동작하는 원인을 파악하고, 인덱스 추가/수정, 쿼리 재작성 등을 통해 최적의 실행 계획이 수립되도록 유도하는 것이 쿼리 튜닝의 핵심입니다.

## **5. TCP와 UDP의 차이점에 대해 설명하고, 각각 어떤 경우에 사용하는 것이 적합할까요?(네트워크)**

**TCP(Transmission Control Protocol)**와 **UDP(User Datagram Protocol)** 는 **전송 계층(OSI 4계층)** 프로토콜로, 데이터 전송 방식을 결정합니다.

| 특징 | TCP | UDP |
| --- | --- | --- |
| **연결 방식** | **연결 지향형(Connection-oriented)** | **비연결 지향형(Connectionless)** |
| **신뢰성** | **높음** (데이터 순서 보장, 오류 검출 및 재전송) | **낮음** (데이터 순서, 도착 여부 보장 안 함) |
| **제어 기능** | 흐름 제어(Flow Control), 혼잡 제어(Congestion Control) | 없음 |
| **전송 단위** | 세그먼트(Segment) | 데이터그램(Datagram) |
| **속도** | 느림 | 빠름 |
| **헤더 크기** | 큼 (20바이트 이상) | 작음 (8바이트) |
| **비유** | 전화 통화 (상대방 확인 후 대화 시작) | 우편 엽서 (확인 없이 그냥 보냄) |

**적합한 사용 사례:**

*   **TCP:** 신뢰성이 중요한 서비스에 사용됩니다.
    -   **HTTP/HTTPS:** 웹 페이지 데이터가 누락되면 안 되므로 사용합니다.
    -   **FTP (File Transfer Protocol):** 파일 전송 시 데이터가 유실되면 안 됩니다.
    -   **SMTP (Simple Mail Transfer Protocol):** 이메일 전송에 사용됩니다.

*   **UDP:** 속도가 중요하고, 약간의 데이터 손실이 허용되는 서비스에 사용됩니다.
    -   **DNS (Domain Name System):** 빠른 응답이 중요하며, 요청 실패 시 애플리케이션 레벨에서 재시도하면 됩니다.
    -   **실시간 스트리밍 (VoIP, 비디오):** 약간의 프레임 손실이 있더라도 끊김 없이 빠르게 전송하는 것이 더 중요합니다.
    -   **온라인 게임:** 플레이어의 위치 정보를 실시간으로 빠르게 전달해야 합니다.

---

### **꼬리질문 1: TCP의 3-way handshake와 4-way handshake 과정에 대해 설명해주세요.**

1.  **3-Way Handshake (연결 수립 과정):**
    -   **목적:** 통신을 시작하기 전에 클라이언트와 서버 양측이 서로 통신할 준비가 되었음을 확인하고, 초기 시퀀스 번호(ISN)를 교환하는 과정입니다.
    -   **과정:**
        1.  **[Client → Server] `SYN`:** 클라이언트가 서버에 접속을 요청하며 `SYN`(Synchronize) 패킷을 보냅니다. 이때 자신의 초기 시퀀스 번호(`client_isn`)를 함께 보냅니다. (상태: `SYN-SENT`)
        2.  **[Server → Client] `SYN+ACK`:** 서버는 요청을 수락하며, 자신도 통신 준비가 되었음을 알리는 `SYN` 패킷과 클라이언트의 요청을 잘 받았다는 `ACK`(Acknowledge) 패킷을 함께 보냅니다. 이때 자신의 초기 시퀀스 번호(`server_isn`)와 `ack` 번호(`client_isn + 1`)를 보냅니다. (상태: `SYN-RECEIVED`)
        3.  **[Client → Server] `ACK`:** 클라이언트는 서버의 응답을 받고, 서버의 요청을 잘 받았다는 `ACK` 패킷을 보냅니다. 이때 `ack` 번호(`server_isn + 1`)를 보냅니다. 이 패킷을 받은 서버는 연결이 수립되었음을 확인합니다. (상태: `ESTABLISHED`)

2.  **4-Way Handshake (연결 해제 과정):**
    -   **목적:** 안전하게 TCP 연결을 종료하는 과정입니다.
    -   **과정:**
        1.  **[Client → Server] `FIN`:** 클라이언트가 서버에 연결 종료를 알리는 `FIN`(Finish) 패킷을 보냅니다. (상태: `FIN_WAIT_1`)
        2.  **[Server → Client] `ACK`:** 서버는 클라이언트의 종료 요청을 받았음을 알리는 `ACK` 패킷을 보냅니다. 이때 서버는 아직 보낼 데이터가 남아있을 수 있으므로, 바로 연결을 끊지 않고 데이터를 마저 전송합니다. (클라이언트 상태: `FIN_WAIT_2`, 서버 상태: `CLOSE_WAIT`)
        3.  **[Server → Client] `FIN`:** 서버가 모든 데이터를 전송하고 나면, 자신도 연결을 종료하겠다는 `FIN` 패킷을 클라이언트에 보냅니다. (상태: `LAST_ACK`)
        4.  **[Client → Server] `ACK`:** 클라이언트는 서버의 종료 요청을 받았다는 `ACK` 패킷을 보냅니다. 이 패킷을 받은 서버는 즉시 연결을 종료합니다. 클라이언트는 혹시 모를 패킷 유실에 대비해 일정 시간(`TIME_WAIT`) 동안 대기한 후 연결을 완전히 종료합니다. (상태: `TIME_WAIT` -> `CLOSED`)

---

### **꼬리질문 2: TCP의 흐름 제어(Flow Control)와 혼잡 제어(Congestion Control)는 어떻게 동작하나요?**

*   **흐름 제어 (Flow Control):**
    -   **목적:** **송신 측(Sender)과 수신 측(Receiver) 사이**의 데이터 처리 속도 차이를 해결하기 위한 기법입니다. 수신 측이 감당할 수 없을 만큼 많은 데이터를 송신 측이 보내지 않도록 조절합니다.
    -   **동작 방식 (Sliding Window):**
        1.  수신 측은 3-way handshake 시 자신의 **수신 버퍼 크기(Receive Window Size)** 를 송신 측에 알립니다.
        2.  송신 측은 이 윈도우 크기만큼만 데이터를 연속적으로 보낼 수 있습니다.
        3.  수신 측은 데이터를 처리한 후, 현재 남아있는 버퍼 크기를 `ACK` 패킷의 `Window Size` 필드에 담아 송신 측에 계속 업데이트해줍니다.
        4.  송신 측은 이 윈도우 크기에 맞춰 데이터 전송량을 동적으로 조절합니다.

*   **혼잡 제어 (Congestion Control):**
    -   **목적:** **네트워크 전체**의 혼잡(Congestion) 상황을 고려하여 데이터 전송량을 조절하는 기법입니다. 라우터나 스위치 같은 네트워크 장비에 과부하가 걸리지 않도록 합니다.
    -   **동작 방식 (AIMD, Slow Start, Fast Retransmit/Recovery):**
        1.  **Slow Start:** 연결 초기에는 **혼잡 윈도우(Congestion Window, `cwnd`)** 크기를 1부터 시작하여, `ACK`를 받을 때마다 지수적으로(2배씩) 늘려가며 전송량을 빠르게 증가시킵니다.
        2.  **AIMD (Additive Increase, Multiplicative Decrease):**
            -   Slow Start 중 임계값(Threshold)에 도달하거나, 패킷 유실이 감지되면 혼잡이 발생했다고 판단합니다.
            -   **Additive Increase:** 혼잡이 없는 상태에서는 `cwnd`를 1씩 선형적으로 증가시킵니다.
            -   **Multiplicative Decrease:** 타임아웃 등으로 패킷 유실이 감지되면, `cwnd`를 1로 줄이고 임계값을 절반으로 낮춘 뒤 다시 Slow Start를 시작합니다.
        3.  **빠른 재전송/빠른 회복 (Fast Retransmit/Recovery):** 중복된 `ACK`가 3번 연속으로 도착하면, 타임아웃을 기다리지 않고 즉시 해당 패킷을 재전송합니다. 이때 `cwnd`를 절반으로만 줄이고 선형 증가를 시작하여, 네트워크 효율 저하를 최소화합니다.

---

### **꼬리질문 3: HTTP/3에서 UDP 기반의 QUIC 프로토콜을 채택한 이유는 무엇일까요?**

HTTP/3가 TCP 대신 UDP 기반의 **QUIC(Quick UDP Internet Connections)** 프로토콜을 채택한 주된 이유는 **TCP의 근본적인 한계인 HOLB(Head-of-Line Blocking) 문제를 해결**하기 위함입니다.

*   **TCP의 HOLB 문제:** TCP는 패킷의 순서를 엄격하게 보장합니다. 만약 여러 데이터를 동시에 전송할 때(HTTP/2의 멀티플렉싱), 중간에 하나의 패킷이 유실되면 그 패킷이 재전송될 때까지 **후속 패킷들이 모두 대기**해야 합니다. 이는 전체 통신 지연으로 이어집니다.

*   **QUIC의 해결 방식:**
    1.  **독립적인 스트림(Stream) 처리:** QUIC은 UDP 위에서 TCP의 신뢰성 기능(순서 보장, 오류 제어)을 직접 구현합니다. 이때 각 데이터 스트림을 완전히 독립적으로 처리합니다. 따라서 한 스트림에서 패킷 유실이 발생해도, 다른 스트림은 영향을 받지 않고 계속 데이터를 전송할 수 있습니다.
    2.  **연결 수립 시간 단축:** TCP는 3-way handshake, TLS는 TLS handshake를 거쳐 연결 수립에 시간이 걸립니다. QUIC은 이 두 과정을 통합하여, 첫 연결 시 1-RTT(Round Trip Time), 재연결 시에는 0-RTT만으로 연결을 수립할 수 있어 지연 시간을 크게 줄입니다.
    3.  **Connection Migration:** 사용자의 네트워크 환경이 바뀔 때(예: Wi-Fi → LTE), TCP는 IP 주소가 바뀌므로 연결을 다시 맺어야 합니다. QUIC은 IP 주소와 무관한 **Connection ID** 를 기반으로 연결을 유지하므로, 네트워크가 바뀌어도 끊김 없이 통신을 이어갈 수 있습니다.

결론적으로, QUIC은 UDP의 빠른 속도와 낮은 오버헤드를 기반으로 TCP의 신뢰성 기능과 HTTP/2의 멀티플렉싱을 더 효율적으로 구현하여, 웹 통신의 성능과 안정성을 극대화하기 위해 채택되었습니다.

## **6. JVM(Java Virtual Machine)의 메모리 구조에 대해 설명해주세요.(JAVA)**

JVM은 자바 애플리케이션을 실행하기 위한 가상 머신으로, 운영체제로부터 할당받은 메모리 영역(Runtime Data Area)을 다음과 같이 나누어 관리합니다.

1.  **Method Area (모든 스레드 공유):**
    -   클래스 로더가 로드한 클래스의 메타데이터(클래스 정보, 필드, 메서드, 생성자 등), static 변수, 상수(Runtime Constant Pool) 등이 저장됩니다.
    -   Java 8부터는 `PermGen` 영역이 사라지고, **`Metaspace`** 라는 Native Memory 영역에 저장되어 관리됩니다.

2.  **Heap Area (모든 스레드 공유):**
    -   `new` 키워드를 통해 생성된 모든 **객체(인스턴스)와 배열** 이 저장되는 공간입니다.
    -   **Garbage Collection(GC)**의 주된 대상이 되는 영역입니다.
    -   성능 최적화를 위해 보통 **Young Generation**과 **Old Generation**으로 나뉩니다.
        -   **Young Generation:** 대부분의 객체가 처음 생성되는 영역. `Eden`과 두 개의 `Survivor` 공간으로 구성됩니다. 이곳에서 발생하는 GC를 **Minor GC**라고 합니다.
        -   **Old Generation:** Young Generation에서 여러 번의 GC 후에도 살아남은 객체들이 이동하는 영역입니다. 이곳에서 발생하는 GC를 **Major GC(Full GC)**라고 합니다.

3.  **Stack Area (스레드별로 생성):**
    -   메서드 호출 시마다 **스택 프레임(Stack Frame)** 이 생성되어 쌓이는 영역입니다.
    -   각 스택 프레임에는 **지역 변수, 매개변수, 연산 중간 결과, 메서드 반환 주소** 등이 저장됩니다.
    -   메서드 호출이 끝나면 해당 스택 프레임은 스택에서 제거(pop)됩니다.

4.  **PC Register (스레드별로 생성):**
    -   Program Counter의 약자로, 현재 스레드가 실행하고 있는 JVM 명령어의 주소를 가리킵니다.
    -   스레드가 컨텍스트 스위칭 후 돌아왔을 때, 어디서부터 다시 실행해야 할지 알려주는 역할을 합니다.

5.  **Native Method Stack (스레드별로 생성):**
    -   자바 코드가 아닌 C, C++ 등 네이티브 코드로 작성된 메서드를 호출할 때 사용되는 스택 영역입니다.

---

### **꼬리질문 1: GC(Garbage Collection)는 어떻게 동작하나요? GC의 대상이 되는 객체는 어떻게 판단할까요?**

**GC(Garbage Collection)** 는 Heap 영역에서 더 이상 사용되지 않는 객체(쓰레기)를 찾아내어 메모리에서 해제하는 자동 메모리 관리 기능입니다.

*   **GC 대상 판단 (Reachability):**
    -   GC는 **GC Root**에서부터 시작하여, 참조 사슬을 따라가며 도달할 수 있는 객체(Reachable)와 도달할 수 없는 객체(Unreachable)를 식별합니다.
    -   **GC Root** 가 될 수 있는 것들: Stack 영역의 변수, Method Area의 static 변수, JNI(Native Method)에 의해 참조되는 객체 등
    -   **Unreachable 객체**, 즉 GC Root로부터의 참조가 하나도 없는 객체가 GC의 대상이 됩니다. 이 과정을 **Mark**라고 합니다.

*   **GC 동작 방식 (Generational Garbage Collection):**
    1.  **Mark and Sweep:**
        -   **Mark:** GC Root에서 시작하여 참조되는 모든 객체를 마킹합니다.
        -   **Sweep:** 마킹되지 않은 객체(Unreachable)들을 메모리에서 제거합니다.
        -   **단점:** Sweep 이후 메모리 공간에 단편화(Fragmentation)가 발생할 수 있습니다.
    2.  **Mark-Compact:** Sweep 대신, 살아남은 객체들을 한쪽으로 모아(Compaction) 단편화를 해결합니다.
    3.  **Generational GC (Young/Old 세대 기반):**
        -   **"대부분의 객체는 금방 죽는다(Weak Generational Hypothesis)"** 는 가설에 기반합니다.
        -   **Minor GC (Young Generation):**
            1.  새로운 객체는 `Eden` 영역에 생성됩니다.
            2.  `Eden`이 꽉 차면 Minor GC가 발생합니다.
            3.  살아남은 객체는 비어있는 `Survivor` 영역(S1)으로 이동하고, `Eden`과 사용된 `Survivor`(S0) 영역은 비워집니다. 객체의 age는 1 증가합니다.
            4.  이 과정이 반복되며, 객체들은 두 `Survivor` 영역을 오갑니다.
        -   **Major GC (Old Generation):**
            1.  `Survivor` 영역에서 age가 특정 임계값 이상이 된 객체는 `Old Generation`으로 이동(Promotion)합니다.
            2.  `Old Generation` 영역이 꽉 차면 **Major GC(또는 Full GC)** 가 발생합니다. Major GC는 Minor GC보다 훨씬 오래 걸리므로, 발생 빈도를 줄이는 것이 성능 튜닝의 핵심입니다.

---

### **꼬리질문 2: 자바에서 스택 오버플로우(StackOverflowError)와 힙 메모리 부족(OutOfMemoryError)은 각각 어떤 경우에 발생하나요?**

*   **`StackOverflowError`:**
    -   **원인:** **Stack 영역**에 할당된 메모리보다 더 많은 스택 프레임이 쌓일 때 발생합니다.
    -   **주요 발생 상황:**
        -   **무한 재귀 호출:** 재귀 함수의 종료 조건이 없거나 잘못되었을 때, 메서드 호출이 끝나지 않고 계속 스택 프레임을 쌓다가 발생합니다.
        -   매우 깊은 메서드 호출 체인

*   **`OutOfMemoryError`:**
    -   **원인:** **Heap 영역**에 더 이상 객체를 할당할 공간이 없을 때 발생합니다. GC를 수행해도 공간을 확보하지 못하는 경우입니다.
    -   **주요 발생 상황:**
        -   **메모리 누수 (Memory Leak):** 더 이상 사용되지 않는 객체에 대한 참조가 계속 남아있어 GC가 수거하지 못하고, 이 객체들이 Heap에 계속 쌓일 때 발생합니다.
        -   **대용량 데이터 처리:** 한 번에 너무 큰 데이터를 메모리에 로드하려고 할 때 발생합니다. (예: 대용량 파일, 고화질 이미지)
        -   JVM에 할당된 힙 크기(`-Xmx` 옵션) 자체가 너무 작을 경우에도 발생할 수 있습니다.

---

### **꼬리질문 3: 클래스 로더(Class Loader)의 역할과 동작 방식에 대해 설명해주세요.**

**클래스 로더** 는 자바 런타임 시점(Runtime)에 `*.class` 파일을 JVM의 **Method Area**에 동적으로 로드하는 역할을 합니다.

**주요 특징 및 동작 방식:**

1.  **동적 로딩 (Dynamic Loading):** 클래스는 애플리케이션 시작 시 한 번에 모두 로드되는 것이 아니라, 처음으로 사용될 때 로드됩니다. 이는 메모리 사용을 효율화합니다.

2.  **계층 구조 (Hierarchical Structure):** 클래스 로더는 부모-자식 관계의 계층 구조를 가집니다.
    -   **부트스트랩 클래스 로더 (Bootstrap Class Loader):** 최상위 로더. `JAVA_HOME/lib`에 있는 핵심 자바 API(`rt.jar` 등)를 로드합니다. (Native 코드로 구현)
    -   **확장 클래스 로더 (Extension Class Loader):** `JAVA_HOME/lib/ext`에 있는 확장 라이브러리를 로드합니다.
    -   **애플리케이션 클래스 로더 (Application/System Class Loader):** 개발자가 작성한 클래스, 즉 `classpath`에 있는 클래스들을 로드합니다.

3.  **위임 모델 (Delegation Model):**
    -   클래스 로딩 요청이 들어오면, 현재 클래스 로더는 직접 처리하지 않고 **부모 클래스 로더에게 먼저 위임**합니다.
    -   부모 로더도 자신의 부모에게 계속 위임하여, 최상위인 부트스트랩 로더까지 요청이 올라갑니다.
    -   부모 로더가 클래스를 찾지 못했을 때만, 비로소 자식 로더가 직접 클래스를 찾아 로드합니다.
    -   **장점:**
        -   **중복 로딩 방지:** 이미 상위 로더가 로드한 클래스는 하위 로더가 다시 로드하지 않아 메모리 낭비를 막습니다.
        -   **보안:** 사용자가 `java.lang.String`과 같은 핵심 API 클래스를 임의로 조작하여 로드하는 것을 방지합니다. (상위 부트스트랩 로더가 항상 먼저 로드하므로)

## **7. 객체지향 프로그래밍(OOP)의 4가지 주요 특징(캡슐화, 상속, 다형성, 추상화)에 대해 설명해주세요.(JAVA)**

1.  **캡슐화 (Encapsulation):**
    -   **정의:** 관련된 데이터(속성)와 그 데이터를 처리하는 행위(메서드)를 하나의 객체로 묶고, 외부에서 객체의 데이터에 직접 접근하는 것을 막는 것입니다.
    -   **목적:** 데이터 은닉(Data Hiding)을 통해 객체의 무결성을 보장하고, 외부에는 필요한 기능(메서드)만 노출하여 인터페이스를 단순화합니다.
    -   **구현:** 접근 제어자(`private`, `protected`, `public`)를 사용합니다. 데이터는 `private`으로 보호하고, 데이터에 접근할 수 있는 `public` 메서드(Getter/Setter)를 제공합니다.

2.  **상속 (Inheritance):**
    -   **정의:** 기존 클래스(부모 클래스, 슈퍼 클래스)의 속성과 메서드를 새로운 클래스(자식 클래스, 서브 클래스)가 물려받는 것입니다.
    -   **목적:** 코드의 재사용성을 높이고, 클래스 간의 계층 구조를 형성하여 프로그램을 체계적으로 확장할 수 있게 합니다.
    -   **구현:** `extends` 키워드를 사용합니다. (예: `class Dog extends Animal`)

3.  **다형성 (Polymorphism):**
    -   **정의:** '여러 가지 형태를 가질 수 있는 능력'으로, 동일한 요청(메서드 호출)에 대해 객체의 타입에 따라 서로 다른 방식으로 응답하는 것을 의미합니다.
    -   **목적:** 코드의 유연성과 확장성을 높입니다. 클라이언트는 객체의 구체적인 타입에 의존하지 않고, 공통된 인터페이스에만 의존하게 되어 결합도가 낮아집니다.
    -   **구현:** 오버라이딩(Overriding), 오버로딩(Overloading), 인터페이스 구현 등을 통해 실현됩니다.
    -   **예시:** `Animal animal = new Dog(); animal.speak();` 와 같이 부모 타입의 참조 변수로 자식 객체를 참조하고, 호출된 `speak()` 메서드는 실제 객체인 `Dog`의 메서드가 실행됩니다.

4.  **추상화 (Abstraction):**
    -   **정의:** 객체의 공통적인 속성과 기능(본질)을 추출하고, 불필요한 세부 사항은 숨기는 과정입니다.
    -   **목적:** 복잡한 현실 세계를 단순화하여 모델링하고, 개발자가 현재 관심사에만 집중할 수 있도록 돕습니다.
    -   **구현:** 추상 클래스(Abstract Class)나 인터페이스(Interface)를 사용합니다.
    -   **예시:** 자동차를 운전할 때, 우리는 '핸들을 돌린다', '엑셀을 밟는다'와 같은 추상적인 인터페이스만 알면 되고, 내부 엔진의 복잡한 동작 원리까지 알 필요는 없습니다.

---

### **꼬리질문 1: SOLID 원칙에 대해 설명하고, 각 원칙이 왜 중요한지 구체적인 예시를 들어 설명해주세요.**

SOLID는 객체지향 설계에서 지켜야 할 5가지 핵심 원칙으로, 유지보수하기 좋고 유연하며 확장성 있는 소프트웨어를 만들기 위한 지침입니다.

1.  **SRP (Single Responsibility Principle, 단일 책임 원칙):**
    -   **"한 클래스는 단 하나의 책임만 가져야 한다."**
    -   **중요성:** 클래스가 변경되어야 하는 이유는 단 하나여야 합니다. 여러 책임을 가지면, 하나의 책임 변경이 다른 책임과 관련된 코드에 영향을 미쳐 예상치 못한 버그를 유발할 수 있습니다.
    -   **예시:** `User` 클래스가 사용자 정보 관리와 이메일 전송 책임을 모두 가지고 있다면, 이메일 전송 로직 변경이 사용자 정보 관리 코드에 영향을 줄 수 있습니다. `User` 클래스와 `EmailService` 클래스로 분리해야 합니다.

2.  **OCP (Open-Closed Principle, 개방-폐쇄 원칙):**
    -   **"소프트웨어 요소(클래스, 모듈, 함수)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다."**
    -   **중요성:** 새로운 기능이 추가될 때 기존 코드를 수정하지 않고도 확장할 수 있어야 합니다. 이는 시스템의 안정성을 높입니다.
    -   **예시:** 결제 수단을 추가할 때, `PaymentProcessor` 클래스의 `if-else` 문을 수정하는 대신, `PaymentMethod` 인터페이스를 만들고 `CreditCardPayment`, `KakaoPayPayment` 클래스가 이를 구현하도록 설계합니다. `PaymentProcessor`는 인터페이스에만 의존하므로, 새로운 결제 수단이 추가되어도 코드를 수정할 필요가 없습니다.

3.  **LSP (Liskov Substitution Principle, 리스코프 치환 원칙):**
    -   **"서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다."**
    -   **중요성:** 자식 클래스는 부모 클래스의 역할을 완벽하게 수행해야 합니다. 이를 위반하면 다형성을 이용한 코드의 신뢰성이 깨집니다.
    -   **예시:** `Rectangle` 클래스를 상속받는 `Square` 클래스가 있다고 가정합시다. `Square`는 너비와 높이가 같아야 하므로 `setWidth()`를 오버라이드하여 높이도 함께 변경합니다. 이는 `Rectangle`의 "너비와 높이는 독립적으로 변경될 수 있다"는 규칙을 깨뜨리므로 LSP를 위반합니다.

4.  **ISP (Interface Segregation Principle, 인터페이스 분리 원칙):**
    -   **"클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안 된다."**
    -   **중요성:** 하나의 거대한 인터페이스보다, 특정 클라이언트를 위한 여러 개의 작은 인터페이스가 더 좋습니다. 불필요한 의존성을 줄여 시스템을 유연하게 만듭니다.
    -   **예시:** `SmartMachine` 인터페이스에 `print()`, `scan()`, `fax()` 메서드가 모두 있다면, `scan()` 기능만 필요한 클라이언트도 `print()`, `fax()` 메서드에 의존하게 됩니다. `Printable`, `Scannable`, `Faxable` 인터페이스로 분리해야 합니다.

5.  **DIP (Dependency Inversion Principle, 의존관계 역전 원칙):**
    -   **"상위 모듈은 하위 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다."** 즉, **"구체화가 아닌 추상화에 의존하라."**
    -   **중요성:** 구체적인 구현 클래스에 직접 의존하면, 해당 클래스가 변경될 때 의존하는 클래스도 함께 변경되어야 합니다. 추상화(인터페이스)에 의존하면, 구현체가 바뀌어도 클라이언트 코드는 영향을 받지 않아 유연성과 재사용성이 높아집니다. Spring의 DI(Dependency Injection)가 이 원칙을 구현한 대표적인 예입니다.
    -   **예시:** `Car` 클래스가 `new SnowTire()`와 같이 구체적인 `SnowTire` 클래스를 직접 생성하면, 여름에는 `SummerTire`로 코드를 변경해야 합니다. 대신 `Tire` 인터페이스에 의존하고, 외부에서 `Tire`의 구현체를 주입받도록(DI) 설계해야 합니다.

---

### **꼬리질문 2: 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이점은 무엇인가요?**

| 구분 | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
| --- | --- | --- |
| **정의** | **같은 이름**의 메서드를 여러 개 정의 | 부모 클래스의 메서드를 자식 클래스에서 **재정의** |
| **위치** | 같은 클래스 내 | 상속 관계의 부모-자식 클래스 간 |
| **조건** | 메서드 이름은 같고, **매개변수의 개수나 타입** 이 달라야 함 | 메서드 이름, 매개변수, 반환 타입이 **모두 같아야 함** |
| **결정 시점** | **컴파일 타임 (정적 바인딩)** | **런타임 (동적 바인딩)** |
| **목적** | 이름이 같은 메서드에 다양한 매개변수를 처리하여 사용 편의성 증대 | 부모의 기능을 자식 클래스의 특성에 맞게 확장하거나 변경 |
| **비유** | 이름은 같지만 역할이 다른 동명이인 | 부모의 가업을 물려받아 자신만의 스타일로 운영하는 자식 |

---

### **꼬리질문 3: 인터페이스(Interface)와 추상 클래스(Abstract Class)의 차이점은 무엇이며, 각각 어떤 상황에서 사용해야 할까요?**

| 구분 | 추상 클래스 (Abstract Class) | 인터페이스 (Interface) |
| --- | --- | --- |
| **목적** | 상속을 통해 **관련성이 높은 클래스 간의 공통 기능** 을 구현하고, 일부 기능을 자식 클래스에서 확장하도록 강제 (IS-A 관계) | 상속 관계가 없는 클래스들에게 **공통된 규약(기능)을 제공**하여 특정 능력을 부여 (HAS-A 또는 CAN-DO 관계) |
| **상속** | `extends` 키워드 사용, **단일 상속**만 가능 | `implements` 키워드 사용, **다중 구현** 가능 |
| **구성 요소** | 추상 메서드, 일반 메서드, 생성자, 멤버 변수 모두 가능 | (Java 8 이전) 추상 메서드, 상수만 가능<br>(Java 8 이후) `default` 메서드, `static` 메서드 추가 |
| **상태** | 멤버 변수를 통해 상태(State)를 가질 수 있음 | 상태를 가질 수 없음 (상수는 예외) |
| **비유** | "미완성 설계도" | "기능 명세서 (스펙)" |

**사용 상황:**

*   **추상 클래스:**
    -   여러 클래스 간에 **공통된 상태(멤버 변수)나 구현(일반 메서드)을 공유**하고 싶을 때.
    -   IS-A 관계가 명확하고, 계층 구조 내에서 코드를 재사용하는 것이 중요할 때.
    -   예: `Animal` 추상 클래스를 만들고, `name`, `age` 변수와 `eat()` 공통 메서드를 구현한 뒤, `Dog`, `Cat` 클래스가 이를 상속받아 `speak()` 추상 메서드만 각자 구현하도록 할 때.

*   **인터페이스:**
    -   서로 관련 없는 클래스들에게 **특정 기능(역할)을 부여**하고 싶을 때.
    -   다중 상속의 효과를 내고 싶을 때.
    -   구현체의 종류에 관계없이 특정 규약을 따르도록 강제하고 싶을 때 (예: DI, 전략 패턴).
    -   예: `Flyable` 인터페이스를 만들어 `Bird`, `Airplane`, `Drone` 등 서로 다른 클래스들이 '날 수 있다'는 공통 기능을 갖도록 할 때.

## **8. 웹 서버(Web Server)와 WAS(Web Application Server)의 차이점에 대해 설명해주세요.(네트워크)**

*   **웹 서버 (Web Server):**
    -   **역할:** HTTP 프로토콜을 통해 클라이언트로부터 요청을 받아 **정적 콘텐츠(HTML, CSS, JavaScript, 이미지)** 를 제공하는 서버입니다.
    -   **기능:** 정적 파일 제공, 리버스 프록시, 로드 밸런싱 등.
    -   **예시:** Nginx, Apache HTTP Server

*   **WAS (Web Application Server):**
    -   **역할:** 웹 서버의 기능에 더해, **동적 콘텐츠** 를 생성하는 역할을 수행합니다. 비즈니스 로직을 실행하고, 데이터베이스와 연동하여 요청에 따라 실시간으로 다른 결과를 만들어 제공합니다.
    -   **기능:** 서블릿 컨테이너(Servlet Container)를 내장하여 JSP, Servlet 실행, 트랜잭션 관리, 스레드 풀 관리 등.
    -   **예시:** Tomcat, JBoss, WebLogic, Jetty

**핵심 차이:** **콘텐츠의 종류**에 있습니다. 웹 서버는 미리 만들어진 정적 콘텐츠를 제공하는 데 특화되어 있고, WAS는 비즈니스 로직을 통해 동적 콘텐츠를 생성하는 데 특화되어 있습니다.

---

### **꼬리질문 1: Nginx와 같은 리버스 프록시(Reverse Proxy)를 사용하는 이유는 무엇인가요?**

**리버스 프록시** 는 클라이언트의 요청을 직접 처리하지 않고, 내부망에 있는 여러 대의 WAS 중 하나에 요청을 전달하고 그 결과를 받아 클라이언트에 대신 응답해주는 서버입니다.

**사용 이유:**

1.  **로드 밸런싱 (Load Balancing):** 여러 대의 WAS로 트래픽을 분산시켜 특정 서버에 과부하가 걸리는 것을 방지하고, 시스템 전체의 처리 성능과 안정성을 높입니다.
2.  **보안 강화 (Security):** 클라이언트는 리버스 프록시 서버의 IP만 알 수 있고, 실제 WAS의 존재와 IP 주소를 알 수 없습니다. 이를 통해 내부 서버를 외부로부터 숨기고, 리버스 프록시 단에서 SSL 암호화, DDoS 공격 방어, IP 필터링 등을 수행할 수 있습니다.
3.  **캐싱 (Caching):** 자주 요청되는 정적 콘텐츠를 리버스 프록시 서버에 캐싱해두면, WAS까지 요청이 도달하지 않고 바로 응답할 수 있어 WAS의 부하를 줄이고 응답 속도를 향상시킬 수 있습니다.
4.  **무중단 배포:** 새로운 버전의 애플리케이션을 배포할 때, 리버스 프록시가 트래픽을 점진적으로 새로운 버전의 WAS로 전환시켜 서비스 중단 없이 배포를 가능하게 합니다.

---

### **꼬리질문 2: 로드 밸런싱(Load Balancing)이란 무엇이며, 어떤 알고리즘들이 있나요?**

**로드 밸런싱** 은 서버에 가해지는 부하(Load)를 여러 대의 서버에 균등하게 분산(Balancing)시켜주는 기술입니다. 이를 통해 시스템의 가용성(Availability)과 확장성(Scalability)을 확보할 수 있습니다.

**주요 알고리즘:**

*   **라운드 로빈 (Round Robin):** 요청을 서버 목록 순서대로 돌아가며 분배하는 가장 간단한 방식입니다.
*   ** 가중 라운드 로빈 (Weighted Round Robin):** 서버의 처리 성능(사양)에 따라 가중치를 부여하고, 가중치가 높은 서버에 더 많은 요청을 분배합니다.
*   **최소 연결 (Least Connection):** 현재 연결(세션) 수가 가장 적은 서버에 요청을 분배합니다. 서버들의 성능이 비슷할 때 효과적입니다.
*   **IP 해시 (IP Hash):** 클라이언트의 IP 주소를 해싱하여 특정 서버로만 요청을 보내는 방식입니다. 사용자가 항상 같은 서버에 접속해야 하는 경우(세션 클러스터링이 안 된 경우)에 유용합니다.

---

### **꼬리질문 3: 웹 서버와 WAS를 함께 사용하는 구조의 장점은 무엇인가요?**

현대의 웹 서비스는 대부분 웹 서버와 WAS를 함께 사용하는 구조를 채택합니다. 이는 **서버의 역할을 분리하여 효율성과 안정성을 극대화**하기 위함입니다.

**장점:**

1.  **서버 부하 분산:**
    -   정적 콘텐츠는 웹 서버가, 동적 콘텐츠는 WAS가 전담하여 처리합니다. 상대적으로 단순하고 빠른 정적 콘텐츠 처리를 웹 서버에 맡김으로써, WAS는 비즈니스 로직 처리에만 집중할 수 있어 시스템 전체의 성능이 향상됩니다.

2.  **안정성 향상:**
    -   웹 서버를 앞단에 두어 로드 밸런서 역할을 수행하게 하면, 여러 대의 WAS 중 하나에 장애가 발생하더라도 다른 WAS로 요청을 넘겨 서비스 중단을 막을 수 있습니다. (Failover)

3.  **보안 강화:**
    -   웹 서버가 외부 공격(DDoS 등)을 1차적으로 방어하는 역할을 하고, WAS는 내부망에 위치시켜 외부 노출을 최소화할 수 있습니다.

4.  **효율적인 배포 및 확장:**
    -   정적 콘텐츠만 변경될 경우 웹 서버만 재시작하면 되고, 비즈니스 로직만 변경될 경우 WAS만 재시작하면 됩니다. 또한, 부하가 증가할 때 필요한 부분(WAS 등)만 선택적으로 증설(Scale-out)하기 용이합니다.

## **9. JWT(Json Web Token)의 구조와 인증 방식에 대해 설명해주세요. 세션/쿠키 방식과 비교했을 때 어떤 장단점이 있을까요?(네트워크)**

**JWT(JSON Web Token)** 는 인증에 필요한 정보들을 암호화된 JSON 형태로 표현한 웹 토큰입니다. 서버와 클라이언트 간에 정보를 안전하게 전달하기 위해 사용됩니다.

**구조 (Header.Payload.Signature):**
1.  **Header (헤더):** 토큰의 타입(JWT)과 서명에 사용된 해싱 알고리즘(HS256, RS256 등) 정보를 담습니다.
2.  **Payload (내용):** 토큰에 담을 정보(Claim)를 포함합니다. 사용자의 ID, 이름, 권한 등과 같은 데이터를 담을 수 있으며, 토큰 만료 시간(exp) 등도 여기에 포함됩니다.
3.  **Signature (서명):** `Header`와 `Payload`를 Base64로 인코딩한 값과 서버만 아는 **비밀키(Secret Key)** 를 이용해 헤더에 명시된 알고리즘으로 암호화한 값입니다. 이 서명을 통해 토큰의 위변조 여부를 검증할 수 있습니다.

**인증 방식:**
1.  사용자가 로그인에 성공하면, 서버는 사용자의 정보를 담은 JWT를 생성하여 클라이언트에 전달합니다.
2.  클라이언트는 이 JWT를 로컬 스토리지, 세션 스토리지 등에 저장합니다.
3.  이후 API를 요청할 때마다, 클라이언트는 `Authorization` 헤더에 `Bearer <token>` 형태로 JWT를 담아 서버에 보냅니다.
4.  서버는 받은 JWT의 서명을 자신의 비밀키로 검증하여 토큰의 유효성과 위변조 여부를 확인합니다.
5.  검증이 완료되면, Payload에 담긴 사용자 정보를 기반으로 요청에 대한 인가를 처리합니다.

**세션/쿠키 방식과의 비교:**

| 구분 | 세션/쿠키 | JWT |
| --- | --- | --- |
| **상태 저장** | **서버**에 세션 정보 저장 (Stateful) | **클라이언트**에 토큰 저장 (Stateless) |
| **확장성** | 세션 정보를 모든 서버가 공유해야 하므로 수평 확장(Scale-out)에 불리 | 토큰 자체에 정보가 있어 서버 간 공유가 불필요하므로 수평 확장에 유리 |
| **보안** | 세션 ID만 탈취되면 도용 가능 (CSRF 공격에 취약) | 토큰 자체에 서명이 있어 위변조가 어렵고, Payload가 노출될 수 있음 |
| **범용성** | 주로 웹 브라우저 환경에서 사용 | 모바일 앱, 다른 서비스 등 다양한 플랫폼에서 사용 가능 |
| **오버헤드** | 매 요청마다 DB 조회 등이 필요할 수 있음 | 토큰 검증만 하면 되므로 오버헤드가 적음 |

---

### **꼬리질문 1: Refresh Token은 왜 필요한가요? Access Token과 Refresh Token을 어떻게 안전하게 관리해야 할까요?**

**Refresh Token이 필요한 이유:**

**Access Token** 은 수명이 짧습니다 (보통 30분 ~ 2시간). 만약 Access Token이 탈취되더라도 짧은 시간만 유효하므로 피해를 최소화할 수 있습니다. 하지만 수명이 너무 짧으면 사용자는 계속 다시 로그인해야 하는 불편함이 생깁니다.

이 문제를 해결하기 위해 **Refresh Token** 을 사용합니다. Refresh Token은 Access Token보다 훨씬 긴 수명(예: 2주)을 가지며, Access Token이 만료되었을 때 **새로운 Access Token을 발급받는 용도**로만 사용됩니다.

**안전한 관리 방안:**

*   **Access Token:**
    -   **저장 위치:** 메모리(변수)에 저장하는 것이 가장 안전하지만, 새로고침 시 사라지므로 보통 **로컬 스토리지**나 **세션 스토리지**에 저장합니다. XSS(Cross-Site Scripting) 공격에 취약할 수 있으므로, 스크립트에서 접근하지 못하도록 주의해야 합니다.
    -   **전송:** `Authorization` 헤더에 담아 전송합니다.

*   **Refresh Token:**
    -   **저장 위치:** 로컬 스토리지보다 훨씬 더 안전한 곳에 보관해야 합니다. **HTTP-Only 쿠키**에 저장하는 것이 가장 권장되는 방식입니다. HTTP-Only 속성은 JavaScript로 쿠키에 접근하는 것을 막아주므로 XSS 공격으로부터 안전합니다.
    -   **보안 강화:** 서버의 DB에 Refresh Token을 저장하고, 새로운 Access Token을 발급할 때마다 DB에 저장된 토큰과 일치하는지 확인합니다. 또한, Refresh Token이 사용될 때마다 새로운 Refresh Token을 발급하는 **Refresh Token Rotation** 전략을 사용하면 탈취 시 피해를 줄일 수 있습니다.

---

### **꼬리질문 2: CSRF(Cross-Site Request Forgery) 공격은 무엇이며, JWT를 사용하면 이 공격을 자연스럽게 방어할 수 있는 이유는 무엇인가요?**

**CSRF(사이트 간 요청 위조)** 는 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격입니다. 이 공격은 사용자의 인증 정보가 담긴 **쿠키** 를 브라우저가 요청 시 자동으로 함께 보내는 특성을 악용합니다.

**JWT가 CSRF를 방어하는 이유:**

CSRF 공격은 브라우저의 쿠키 자동 전송 메커니즘에 의존합니다. 하지만 JWT는 일반적으로 쿠키가 아닌 **`Authorization` 헤더**에 담겨 전송됩니다. 이 헤더는 개발자가 API 요청 시 **직접 코드로 추가**해줘야 하므로, 브라우저가 자동으로 포함시키지 않습니다.

따라서 공격자가 만든 피싱 사이트에서 우리 서비스의 API를 호출하더라도, 해당 사이트의 스크립트는 사용자의 JWT를 알 수 없어 `Authorization` 헤더를 구성할 수 없으므로 요청이 실패하게 됩니다. 이로써 JWT를 헤더 기반으로 사용하면 CSRF 공격을 자연스럽게 방어할 수 있습니다. (단, JWT를 쿠키에 저장하면 CSRF에 똑같이 취약해집니다.)

---

### **꼬리질문 3: JWT 토큰의 Payload가 노출되어도 괜찮은 이유는 무엇인가요? 민감한 정보를 토큰에 담아야 할 경우 어떻게 처리해야 할까요?**

JWT의 Payload는 단순히 Base64로 인코딩된 것이므로, 누구나 디코딩하여 내용을 볼 수 있습니다.
따라서 **Payload에는 주민등록번호, 비밀번호와 같은 민감 정보를 절대로 담아서는 안 됩니다.**

Payload가 노출되어도 괜찮은 이유는, 토큰의 **무결성** 이 **서명(Signature)** 을 통해 보장되기 때문입니다.
만약 공격자가 Payload를 변경하더라도, 서버의 비밀키를 모르기 때문에 유효한 서명을 다시 만들어낼 수 없습니다.
서버는 서명 검증을 통해 토큰이 위변조되었음을 즉시 감지할 수 있습니다.

**민감 정보 처리 방안:**

정말로 민감 정보를 토큰화해야 한다면, JWT 표준 스펙인 **JWE(JSON Web Encryption)** 를 사용해야 합니다.
JWE는 Payload 자체를 암호화하여, 비밀키를 가진 서버만이 내용을 복호화할 수 있도록 합니다.

하지만 대부분의 경우, Payload에는 사용자를 식별할 수 있는 최소한의 정보(사용자 ID, 권한 등)만 담고, 민감 정보는 필요할 때마다 DB에서 직접 조회하는 것이 더 안전하고 일반적인 설계 방식입니다.

## **10. 대용량 트래픽을 처리해야 하는 서비스를 설계할 때 고려해야 할 점들은 무엇이 있을까요?(인프라)**

대용량 트래픽을 처리하는 시스템 설계의 핵심은 **부하 분산**과 **장애 허용(Fault Tolerance)**입니다.
즉, 특정 지점에 병목이 생기지 않도록 요청을 분산하고, 일부 컴포넌트에 장애가 발생하더라도 전체 서비스가 중단되지 않도록 설계해야 합니다.

**주요 고려사항:**

1.  **확장성 (Scalability):**
    -   **Scale-out (수평 확장):** 서버의 개수를 늘려 부하를 분산시키는 방식입니다. 로드 밸런서를 통해 트래픽을 여러 서버로 분배합니다.
    -   **Scale-up (수직 확장):** 기존 서버의 사양(CPU, RAM)을 높이는 방식입니다. 한계가 명확하여 보통 Scale-out과 병행합니다.

2.  **데이터베이스 부하 분산:**
    -   **Replication:** Master DB(쓰기 전용)와 여러 개의 Slave DB(읽기 전용)로 구성하여, 쓰기 요청은 Master로, 읽기 요청은 Slave로 분산시켜 DB 부하를 줄입니다.
    -   **Sharding:** 하나의 거대한 테이블을 여러 개의 작은 테이블(샤드)로 분할하여 다른 DB 서버에 저장하는 방식입니다. 데이터가 너무 많아 하나의 DB로 감당이 안 될 때 사용합니다.

3.  **캐싱 (Caching):**
    -   자주 사용되지만 잘 변하지 않는 데이터를 메모리에 저장하여, DB까지 요청이 도달하는 횟수를 줄입니다.
    -   **Local Cache:** 각 서버의 메모리에 캐시 (빠르지만 서버 간 데이터 불일치 문제 발생 가능)
    -   **Global Cache (분산 캐시):** Redis, Memcached와 같은 별도의 캐시 서버를 사용 (서버 간 데이터 일관성 유지, 캐시 서버에 부하 집중 가능)

4.  **비동기 처리 (Asynchronous Processing):**
    -   시간이 오래 걸리는 작업(이메일 발송, 동영상 인코딩 등)을 즉시 처리하지 않고, **메시지 큐(Message Queue)**에 넣어두고 별도의 워커(Worker)가 나중에 처리하도록 합니다.
    -   이를 통해 사용자는 빠른 응답을 받을 수 있고, 갑작스러운 요청 폭주 시에도 시스템이 안정적으로 요청을 처리할 수 있습니다. (예: RabbitMQ, Kafka)

5.  **콘텐츠 전송 네트워크 (CDN, Content Delivery Network):**
    -   이미지, 동영상, CSS/JS 파일과 같은 정적 콘텐츠를 전 세계에 분산된 캐시 서버에 미리 저장해두고, 사용자와 가장 가까운 서버에서 콘텐츠를 전송하여 로딩 속도를 획기적으로 개선합니다.

---

### **꼬리질문 1: Scale-up과 Scale-out의 차이점을 설명하고, 어떤 상황에서 각각의 방식을 선택해야 할까요?**

| 구분 | Scale-up (수직 확장) | Scale-out (수평 확장) |
| --- | --- | --- |
| **정의** | 서버 자체의 성능(CPU, RAM 등)을 높이는 것 | 서버의 개수를 늘리는 것 |
| **장점** | 구현이 간단하고, 데이터 불일치 등 복잡한 문제를 고려할 필요가 없음 | 여러 서버로 부하를 분산하여 높은 가용성 확보, 거의 무한한 확장 가능 |
| **단점**| 하드웨어 성능 향상에 한계가 명확하고 비용이 기하급수적으로 증가, 단일 장애점(SPOF)이 될 수 있음 | 로드 밸런서 등 추가적인 아키텍처 설계가 필요, 서버 간 데이터 일관성 문제 발생 가능 |
| **비유** | 1인 개발자의 컴퓨터를 최고 사양으로 업그레이드 | 여러 명의 개발자를 고용하여 일을 나누어 처리 |

**선택 기준:**

*   **Scale-up:**
    -   **데이터베이스 서버**처럼 데이터 일관성이 매우 중요하고, 분산 처리가 복잡한 경우에 주로 선택됩니다.
    -   애플리케이션 아키텍처를 변경하기 어려울 때 단기적인 해결책으로 사용될 수 있습니다.

*   **Scale-out:**
    -   **웹 서버/WAS**처럼 상태를 저장하지 않거나(Stateless), 상태 공유가 비교적 쉬운 경우에 가장 효과적입니다.
    -   대부분의 대용량 서비스는 Scale-out을 기본 확장 전략으로 사용하며, 필요에 따라 개별 서버를 Scale-up하는 방식을 병행합니다.

---

### **꼬리질문 2: 캐시(Cache)를 적용한다면 어떤 데이터를 캐싱 대상으로 삼을 것이며, 캐시 일관성(Cache Coherence) 문제는 어떻게 해결할 수 있을까요?**

**캐싱 대상 데이터:**
*   **읽기 작업이 쓰기 작업보다 압도적으로 많은 데이터:** 예) 상품 목록, 게시판 목록, 사용자 랭킹
*   **자주 조회되지만 잘 변경되지 않는 데이터:** 예) 설정 정보, 카테고리 목록, 공지사항
*   **계산 비용이 비싼 데이터:** 예) 복잡한 연산 결과, 외부 API 호출 결과

**캐시 일관성 문제 해결 전략:**

캐시 일관성 문제는 **캐시에 있는 데이터**와 **원본 DB에 있는 데이터** 가 달라지는 상황을 의미합니다.

*   **Cache-Aside (Lazy Loading):** 가장 일반적인 전략입니다.
    1.  **읽기:** 캐시에서 데이터를 찾는다. → 없으면(Cache Miss) DB에서 읽어와 캐시에 저장한 후 반환한다. → 있으면(Cache Hit) 바로 반환한다.
    2.  **쓰기:** DB에 데이터를 먼저 쓰고, **캐시에서는 해당 데이터를 삭제**한다. (수정하지 않고 삭제하는 것이 더 간단하고 안전함)

*   **Write-Through:**
    -   **쓰기:** 캐시에 먼저 데이터를 쓰고, 이어서 DB에도 데이터를 쓴다. 두 작업이 모두 완료되어야 성공으로 간주한다.
    -   **장점:** 캐시와 DB의 데이터가 항상 일치한다.
    -   **단점:** 쓰기 작업 시 두 단계를 거치므로 속도가 느리다.

*   **Write-Back (Write-Behind):**
    -   **쓰기:** 캐시에만 데이터를 쓰고, 특정 시간이나 특정 개수만큼 모아서 DB에 비동기적으로 쓴다.
    -   **장점:** 쓰기 성능이 매우 빠르다.
    -   **단점:** 캐시와 DB 사이에 데이터 불일치가 발생할 수 있으며, 캐시에 장애가 발생하면 데이터가 유실될 수 있다.

*   **TTL (Time To Live) 설정:** 캐시 데이터에 유효 시간(예: 10분)을 설정하고, 시간이 지나면 자동으로 삭제되도록 합니다. 데이터가 약간 오래되어도 괜찮은 경우에 사용할 수 있는 가장 간단한 방법입니다.

---

### **꼬리질문 3: 메시지 큐(Message Queue)를 도입하여 비동기 처리를 하는 것의 장점은 무엇이며, 어떤 경우에 사용하는 것이 효과적일까요?**

**메시지 큐(MQ)** 는 생산자(Producer)가 보낸 메시지를 큐에 저장해두었다가, 소비자(Consumer)가 가져가서 처리하는 비동기 통신 방식입니다.

**장점:**

1.  **비동기 처리 및 응답 시간 단축:** 시간이 오래 걸리는 작업을 MQ에 던져두고, 즉시 사용자에게 응답을 줄 수 있습니다. 실제 작업은 백그라운드에서 처리되므로 사용자 경험이 향상됩니다.
2.  **서버 부하 분산:** 갑작스러운 요청 폭주 시, 모든 요청을 즉시 처리하는 대신 MQ에 쌓아두고 컨슈머들이 처리 가능한 속도로 순차적으로 처리할 수 있습니다. 이를 통해 시스템이 다운되는 것을 방지합니다.
3.  **서비스 간 결합도 감소(Decoupling):** 생산자와 소비자는 서로를 직접 알 필요 없이, 오직 MQ에만 의존합니다. 따라서 한쪽 서비스에 장애가 발생하거나 변경되어도 다른 서비스에 영향을 주지 않아 시스템 전체의 안정성과 유연성이 높아집니다.

**효과적인 사용 사례:**

*   **대량 이메일/알림 발송:** 수만 명의 사용자에게 동시에 이메일을 보내는 작업을 MQ에 넣어두고 순차적으로 처리합니다.
*   **주문 처리 시스템:** 사용자의 주문 요청을 받으면 즉시 '주문 접수 완료' 응답을 주고, 실제 재고 차감, 결제 처리, 배송 시스템 연동 등은 MQ를 통해 비동기적으로 처리합니다.
*   **로그 수집 및 분석:** 각 서버에서 발생하는 대량의 로그 데이터를 MQ로 보내고, 별도의 로그 처리 시스템(ELK Stack 등)이 이를 소비하여 분석합니다.
