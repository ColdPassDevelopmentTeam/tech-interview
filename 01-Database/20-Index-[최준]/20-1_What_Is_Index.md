# Index란?

<br>

## 목차
- [Index란?](#index란)
  - [목차](#목차)
    - [정의](#정의)
    - [장점](#장점)
    - [단점](#단점)
    - [사용하면 좋은 경우](#사용하면-좋은-경우)
    - [사용하면 안 좋은 경우](#사용하면-안-좋은-경우)

<br>

### 정의

Index는 데이터베이스 테이블의 검색 속도를 높이기 위한 자료구조

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터 검색 속도를 향상시키는 기술

DB 테이블에 저장된 row를 식별 가능하도록 저장한 DB 오브젝트 

데이터의 위치를 빠르게 찾아주는 역할

<br>

특정 컬럼에 Index를 생성하면?

- 해당 컬럼의 데이터들이 정렬됨
- 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장

<br>

Index가 없다면?

- DB는 원하는 데이터를 찾기 위해 테이블 전체를 처음부터 끝까지 스캔
- = Full Table Scan을 수행해야 하는데 이는 매우 비효율적

비유

- Index : 책의 목차 or 색인
- DB table의 데이터 : 책의 내용
- 데이터의 물리적 주소 : 페이지 번호

<br>

책에서 원하는 내용 찾을 때: 

- 목차를 보고 빠르게 페이지 번호를 찾음
- 해당 페이지로 가서 빠르게 원하는 내용을 찾음

DB table에서 원하는 데이터를 찾을 때:  

- index를 보고 빠르게 데이터 물리적 주소를 얻음
- 데이터 물리적 주소로 빠르게 원하는 데이터를 찾음

<br>

### 장점

**Select 쿼리 (검색 및 조회) 성능 향상**

- Index의 가장 핵심적인 장점
- WHERE 절을 사용해 특정 조건에 맞는 데이터를 찾을 때 유용
    - Full Table Scan X
    - 대신 정렬된 Index를 통해 데이터의 위치를 바로 찾아감
    - 검색 속도 대폭 향상

<br>

**정렬(ORDER BY) 및 그룹화(GROUP BY) 처리 시간 단축**

- Index는 데이터가 이미 정렬된 상태로 저장
- 아래 연산 시 별도의 정렬 과정을 생략하거나 최소화
    - ORDER BY, GROUP BY
    - DISTINCT
        - 정렬되어 중복 값들이 모여 있음
        - 이전 값과 다를 때만 값 가져오면 됨
    - MIN / MAX 함수
        - MIN, MAX 찾으려면 2중 for문 같은 로직 필요
        - but 정렬 되어 있으니 가장 앞, 뒤 값만 가져오면 됨
- 처리 속도가 향상

<br>

**조인(JOIN) 성능 향상**

- Join에 사용되는 컬럼에 index 있다면 Join 작업 성능 크게 개선
- Join 조건에 맞는 Join할 행 빠르게 찾을 수 있기 때문
- 특히 Nested Loop Join에서 효과적

<br>

**데이터 무결성 강화**

- Unique index 사용 시 해당 컬럼에 중복된 값 입력 방지 가능
    - 중복 데이터 검증을 빠르게 수행
- Primary Key나 Unique 제약 조건이 Unique index를 통해 구현
    - INSERT or UPDATE할 때, Full Table Scan 대신 Unique index만 빠르게 확인.
    - 만약 입력하려는 값이 index에 이미 존재한다면?
    - "Unique 제약 조건 위반" 오류를 발생시키며 작업을 거부.
    - 이를 통해 무결성 강화
- 데이터의 정합성과 신뢰성을 보장
- 빠른 유일성 검증을 제공

<br>

**최소 I/O로 데이터 접근 (커버링 인덱스 활용)**

- Index를 통해 데이터 페이지에 직접 접근
    - 테이블 전체를 읽지 않고 필요한 블록만 접근
    - 데이터가 저장된 정확한 물리적 위치를 찾아 한 번에 감
    - 디스크 I/O 횟수를 감소시켜 시스템 전체 성능을 향상
    - Index 없다면 모든 데이터 페이지 하나씩 전부 디스크에서 읽어와야 함
- Covering Index 사용 & SELECT 절에 필요한 모든 컬럼이 Index에 포함되어 있을 경우
    - 테이블 자체에 접근하지 않고 Index만으로 쿼리를 처리 가능
    - 쿼리에 필요한 모든 정보가 Index 안에 다 들어있음
    - 굳이 원본 데이터 있는 테이블까지 찾아갈 필요 없이 인덱스만 읽고 작업을 끝낼 수 있다는 의미

<br>

**옵티마이저 최적화 도움**

- Index는 컬럼의 카디널리티 정보 제공
- 데이터베이스 옵티마이저가 더 나은 실행 계획 세울 수 있도록 도움

<br>

**시스템 부하 감소**

- 전반적인 DB 부하 줄여 시스템 성능 향상
- 불필요한 디스크 I/O 최소화하여 데이터베이스 서버의 CPU 사용률을 낮춤
- 네트워크 트래픽 및 서버 자원 사용량 절약

<br>

### 단점

**쓰기 작업(INSERT, UPDATE, DELETE) 성능 저하**

- 인덱스의 가장 큰 단점이자 주의해야 할 부분
- 새로운 데이터 추가, 수정, 삭제될 때마다 테이블뿐만 아니라 인덱스 테이블에도 추가적인 연산 발생
    - 정렬된 위치를 찾아 데이터를 추가/변경/삭제하는 추가적인 연산 발생
- INSERT (추가) 성능 저하:
    - 새로운 데이터가 추가될 때, 인덱스 테이블에도 정렬된 위치를 찾아 데이터를 추가해야 함
    - 기존 블록에 여유 공간이 없어 새로운 블록을 할당받고 키를 옮기는 Index Split 현상 발생 가능
    - 이 과정은 복잡하고 많은 Redo를 유발하며, DML을 블로킹할 수 있어 성능에 매우 불리
- DELETE (삭제) 성능 저하:
    - 데이터를 삭제할 때, 테이블에서는 데이터가 지워지고 그 공간을 다른 데이터가 사용할 수 있음
    - 하지만 인덱스에서는 데이터가 실제로 지워지지 않고 '사용 안 됨' 표시만 해두는 경우 많음
    - 이로 인해 테이블의 데이터 수와 인덱스의 데이터 수가 달라질 수 있음
    - 인덱스 크기가 불필요하게 커져 성능 저하로 이어질 수 있음
- UPDATE (수정) 성능 저하:
    - 인덱스에는 Update 개념이 없음
    - 테이블에서 업데이트가 발생할 경우 인덱스에서는 기존 데이터를 삭제
    - 그리고 새로운 데이터를 추가하는 것과 같은 작업이 발생
    - 이는 delete와 insert 두 개의 작업이 동시에 일어나 다른 DML보다 더 큰 부하를 주게 됨

<br>

**추가 저장 공간 필요**

- 인덱스는 원본 테이블과는 별도의 디스크 저장 공간을 차지하는 객체
- 보통 원본 테이블 크기의 약 10% 정도의 저장 공간이 필요
- Update 작업이 많은 경우 실제 데이터보다 인덱스가 과도하게 커질 수 있음

<br>

**인덱스 관리 비용 및 복잡성**

- 인덱스 생성에 시간이 많이 소요될 수 있음
- 한 번 만들고 끝나는 것이 아니라 지속적인 관리 필요
- 데이터 변경이 빈번하게 일어나면 인덱스의 조각화(Fragmentation) 발생하여 효율 떨어짐
    - 이 경우 인덱스를 재구성하거나 재정렬하는 등의 추가적인 관리 작업이 필요
- 불필요한 인덱스를 만들면 성능 저하와 관리 비용만 증가.
- 너무 많은 인덱스는 오히려 성능 저하 유발
- 주기적인 인덱스 최적화 및 재구성 작업 필요

<br>

**옵티마이저의 잘못된 인덱스 선택 가능성**

- 아래의 경우에 오히려 Full Table Scan보다 느려져 성능이 저하될 수 있습니다.
    - 옵티마이저가 통계 정보를 잘못 판단해 잘못된 인덱스 선택
    - 인덱스가 쿼리 조건에 맞지 않음
    - 낮은 카디널리티 컬럼 or 소규모 테이블에 인덱스 만듬
    - 인덱스가 처리하는 데이터가 전체 데이터의 10-15% 이상 처리하는 경우
- 인덱스가 너무 많으면 옵티마이저가 잘못된 인덱스를 선택할 위험이 증가
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생

<br>

**복잡한 쿼리에서는 제한적**

- 복합 조건, 다중 조인, 함수가 적용된 조건 등에서는 인덱스가 무시될 수 있음
- 모든 쿼리 패턴을 커버하는 인덱스를 만들 수 없으므로 설계 시 trade-off 고려할 필요 있음

<br>

### 사용하면 좋은 경우

**WHERE절에서 자주 사용하는 컬럼**

- 가장 대표적이고 효과적인 경우
- WHERE 절은 특정 조건을 만족하는 데이터를 필터링하는 역할
- 여기에 사용되는 컬럼에 인덱스가 있으면 Full Table Scan 하지 않고 필요한 데이터에 바로 접근

<br>

**카디널리티가 높은 컬럼** 

- 카디널리티는 특정 컬럼의 데이터 중복 정도를 나타내는 말
- 중복이 적고 값이 넓게 퍼진 컬럼에 인덱스를 사용해야 효율적
- 인덱스는 검색 범위를 좁히는 것이 목적인데, 고유한 값이 많을수록 더 효과적으로 범위 좁힐 수 있기 때문
- 카디널리티 낮으면 많은 데이터 좁히지 못해 추가적인 작업 해야 함
    - 주민 번호에 index → 전체 사람 데이터에서 한명의 사람 데이터 찾아냄
    - 성별에 index → 전체 사람 데이터에서 절반의 데이터 찾아

<br>

**JOIN 조건으로 자주 사용하는 컬럼**

- JOIN의 ON 절에 사용되는 컬럼에 인덱스 설정하면 조인 성능이 크게 향상
- 대부분의 DB 시스템은 외래 키를 설정하면 자동으로 인덱스를 생성

<br>

**ORDER BY, GROUP BY, DISTINCT에 자주 사용하는 컬럼**

- 데이터베이스가 결과 반환하기 위해 별도의 정렬 작업 수행할 필요가 없어 **처리 속도가 향상**
- 인덱스 자체가 이미 정렬된 상태이기 때문에, 인덱스 순서대로 데이터를 읽어오기만 하면 됨

<br>

**Range Query이 잦을 때**

- BETWEEN, >, <, 날짜 구간, 접두사 LIKE('abc%') 등 범위, prefix 검색은 인덱스로 빠르게 처리 가능

<br>

**Covering Index가 가능한 경우**

- 쿼리에 필요한 컬럼이 인덱스에 모두 포함되어 있는 경우
- 테이블에 가지 않고 인덱스만으로 결과를 반환하여 지연시간과 I/O를 크게 줄일 수 있음

<br>

**규모가 작은 편이 아닌 테이블**

- 데이터 양이 적은 테이블에서는 인덱스 사용이 오히려 비효율적
- 규모가 어느 정도 있는 테이블에 사용하는 것이 효과 극대화

<br>

**읽기 위주인  = INSERT, UPDATE, DELETE가 자주 발생하지 않는 테이블, 컬럼**

- SELECT 비중이 높은 테이블일수록 인덱스의 이점이 커짐
- 잦은 DML 없는 컬럼일수록 유지 비용이 낮아 효과적

<br>

**PRIMARY KEY / UNIQUE 제약 조건**

- PRIMARY KEY나 UNIQUE 제약은 내부적으로 인덱스를 사용
- 이를 통해 빠른 유일성 검증과 조회 성능을 동시에 제공

<br>

**LIMIT / TOP-N Query**

- 인덱스를 활용하면 정렬된 결과에서 필요한 일부 데이터만 빠르게 가져올 수 있기 때문

<br>

### 사용하면 안 좋은 경우

**데이터 변경(INSERT, UPDATE, DELETE) 작업이 매우 빈번한 경우**

- **인덱스를 피해야 하는 가장 대표적인 경우**
- 추가, 수정, 삭제될 때마다 테이블뿐만 아니라 인덱스도 함께 정렬하고 수정하는 작업이 발생
    - 시스템에 큰 부하를 주고 인덱스 유지 비용이 커서 성능 병목이 되기 쉬움.
    - 인덱스 유지 비용이 조회 성능 이득을 상쇄
    - 예: 실시간 로그 데이터, 임시 데이터

<br>

**카디널리티가 매우 낮은 컬럼 (데이터 중복도가 높은 컬럼)**

- 값의 종류가 적고 중복이 많은 컬럼에 인덱스를 만드는 것은 비효율적
    - 필터링 효과가 거의 없기 때문
    - 예: 성별, Boolean 값, 회원 등급이 몇 개 없는 경우, Y/N 처리 상태
- 인덱스를 통해 찾아도 결국 전체 데이터의 절반 가량(또는 그 이상)을 읽어야 함
- Full Table Scan과 성능 차이가 거의 없거나 오히려 인덱스를 읽는 비용 때문에 더 느릴 수 있음

<br>

**데이터 양 자체가 매우 적은 테이블 (소규모 테이블)**

- 데이터가 매우 적다면, 인덱스를 사용하는 것보다 그냥 Full Table Scan하는 것이 더 빠름
- 인덱스 사용하는 과정(인덱스 탐색 → 데이터 주소 확인 → 실제 데이터 접근)은 여러 단계 거치기 때문

<br>

**WHERE 절에서 컬럼 가공이 필요한 경우**

- WHERE 절에서 컬럼에 함수 적용하거나 계산을 통해 원래의 값이 바뀌는 컬럼은 인덱스 활용 불가능.
- 인덱스는 **가공되지 않은 순수한 값**으로 검색할 때만 동작

<br>

**검색 결과가 데이터의 상당 부분을 차지하는 경우**:

- WHERE절의 조건으로 검색했을 때, 테이블 전체 데이터의 20~25% 이상을 반환해야 하는 경우
- 일반적으로 전체 데이터의 5-10% 이하 조회 시 Index Scan이 효율적
- 옵티마이저는 인덱스를 사용하는 것보다 Full Table Scan이 더 효율적이라고 판단 가능
- 인덱스를 통해 데이터에 개별적으로 접근하는 랜덤 I/O 비용이, 테이블 전체를 순차적으로 읽는 시퀀셜 I/O 비용보다 더 커지기 때문

<br>

**와일드카드(%)가 앞에 오는 LIKE 검색**

- B-Tree 인덱스는 앞부분이 맞아야 동작
- `%keyword`와 같은 검색은 인덱스를 타지 못하고 Full Table Scan을 발생

<br>

**인덱스가 너무 많은 경우**

- 하나의 테이블에 과도하게 인덱스를 만들면 모든 인덱스 갱신 필요
- **따라서 쓰기 성능 저하**가 심해지고, **저장 공간 낭비**로 이어집니다.
- 또한, 옵티마이저가 **잘못된 인덱스 선택**을 할 위험이 증가하여 오히려 성능을 악화시킬 수 있음.

<br>

**불필요한 중복 인덱스**

- 같은 컬럼에 비슷한 인덱스를 여러 개 두는 경우, 관리 비용만 증가하고 성능에는 이득이 없음