# Index 선택 기준 및 적용 안되는 경우 

<br>

## 목차
- [Index 선택 기준 및 적용 안되는 경우](#index-선택-기준-및-적용-안되는-경우)
  - [목차](#목차)
    - [옵티마이저의 index 선택 기준](#옵티마이저의-index-선택-기준)
    - [Index 적용 안되는 경우](#index-적용-안되는-경우)

<br>

### 옵티마이저의 index 선택 기준

1. **카디널리티, 선택도**
    1. 가장 중요한 기준
    2. 선택도 = 조건 만족하는 행 수 / 전체 행수
    3. 행을 많이 줄일 수 있는 인덱스일수록 우선적 사용
2. **조건절과 인덱스 컬럼 매칭 여부**
    1. WHERE 절, JOIN 조건, ORDER BY, GROUP BY 등에 사용된 컬럼 인덱스와 얼마나 잘 맞는지 확인
    2. 복합 인덱스 시 인덱스 컬럼의 **선두 컬럼 규칙** 충족 여부 중요
3. **비용 체크**
    1. 옵티마이저는 비용을 계산해서 인덱스 vs Full Scan 중 더 효율적인 쪽을 선택
    2. 비용 추정 요소
        - **rows** (예상 읽을 행 수)
        - **filtering ratio** (조건 후 걸러지는 비율)
        - **디스크 I/O 비용**
        - **정렬/그룹핑 필요 여부**
4. **커버링 인덱스 가능 여부**
    1. 인덱스만 읽고 결과 반환 가능한 경우라 선호됨
    2. 테이블 접근이 줄어들어 성능 크게 개선
5. **정렬, 그룹핑 최적화 여부**
    1. ORDER BY / GROUP BY 컬럼 순서가 인덱스 순서와 맞으면 인덱스 선택
    2. 맞지 않으면 filesort/temporary 발생 가능해져서 인덱스 선택 안 할 수도 있음
6. **통계 정보 체크**
    1. 옵티마이저는 테이블과 인덱스에 대한 통계(행 수, 카디널리티, 분포)를 참고해 선택
    2. 통계가 오래되면 잘못된 인덱스 선택 가능
7. **쿼리 형태와 연산자 체크**
    1. 인덱스 활용할 수 없는 쿼리 형태나 연산자 체크
    2. 이런 경우 옵티마이저는 인덱스 선택 X
    3. 어떤 경우들이 있는지 아래에서 확인

<br>

### Index 적용 안되는 경우

인덱스를 분명히 만들었는데도 적용되지 않는 경우가 종종 발생 

데이터베이스의 Optimizer가 인덱스를 사용하는 것이 Full Table Scan보다 비효율적이라고 판단하기 때문

<br>

**인덱스 조건 누락**

- 인덱스가 설정된 컬럼을 WHERE절 조건으로 걸지 않으면 Full Table Scan이 발생

<br>

**컬럼 가공 (연산 or 함수 사용)**

- 인덱스 컬럼에 함수를 적용하거나 연산이 들어가면 인덱스가 무시됨
- 인덱스는 원본 값을 기준으로 정렬되어 있기 때문
- 인덱스는 가공되지 않은 순수한 값으로 검색할 때만 동작
- ex
    - `❌` **나쁜 예**: `WHERE SUBSTRING(name, 1, 2) = '김씨'`
    - `❌` **나쁜 예**: `WHERE score * 10 > 900`
    - `✅` **좋은 예**: `WHERE name LIKE '김씨%'`
    - `✅` **좋은 예**: `WHERE score > 90`

<br>

**LIKE 연산자에서 %가 앞에 위치하는 경우**

- 와일드카드 %가 앞에 오면 인덱스가 적용 X
- 앞부분이 `%`이면 어디서부터 찾아야 할지 모르기 때문에 인덱스를 사용할 수 없음
    - **`‘%abc’`** 의미 = 앞은 아무거나 상관 없고 뒤의 마지막 3글자만 abc
- 앞부분의 글자가 주어진 경우에는 정렬된 위치를 바로 찾아갈 수 있음
    - 접두사 매칭만 인덱스 활용 가능: **`WHERE column LIKE 'abc%'`**
- ex
    - `❌` **나쁜 예**: `WHERE name LIKE '%철수'`
    - `❌` **나쁜 예**: `WHERE name LIKE '%영희%'`
    - `✅` **좋은 예**: `WHERE name LIKE '김%'`

<br>

**비교하는 데이터 타입 불일치 (묵시적 형변환)**

- 인덱스 컬럼의 데이터 타입과 다른 타입으로 비교할 경우 인덱스를 타지 않음
- 데이터베이스 내부적으로 묵시적 형변환 발생으로 인덱스 사용 불가
- 테이블의 모든 행을 읽어 형변환한 후 비교하는 작업을 수행
- 형변환하면 인덱스 컬럼이 함수 처리된 값이 되어 인덱스 사용 불가한 것
- ex
    - **컬럼 타입**: `user_id INT`
    - `❌` **나쁜 예**: `WHERE user_id = '123'`
    - `✅` **좋은 예**: `WHERE user_id = 123`

<br>

**부정형으로 쿼리하는 경우** 

- `!=`, `<>`, `NOT IN`, `IS NULL`과 같은 부정형 조건은 인덱스 효율성 크게 저하
- 왜냐하면 부정형 조건은  특정 데이터를 찾는 것이 아니라, 넓은 범위의 데이터를 제외하는 방식
- 일반적으로 검색해야 할 데이터의 범위가 넓고 불명확
- 대부분의 경우 테이블의 많은 데이터를 읽어야 함
- 따라서 옵티마이저는 Full Table Scan 선택할 가능성 높음
- ex
    - `❌` **나쁜 예**: `WHERE status != 'ACTIVE'`
    - `✅` **좋은 예**: `WHERE status IN ('INACTIVE', 'PENDING')` (대안)

<br>

**OR 조건 사용하는 경우** 

- OR 조건의 의미
    - `WHERE A = 1 OR B = 2`  이 쿼리 의미
    - `A = 1`에 해당하는 집합 + `B = 2`에 해당하는 집합 **합집합하**는 것과 동일
- 옵티마이저는 3가지 선택지 존재 :
    1. `A` 인덱스만 쓰고, 이후 `B = 2` 조건은 필터링으로 처리
    2. `B` 인덱스만 쓰고, 이후 `A = 1` 조건은 필터링
    3. `A` 인덱스 스캔 결과 + `B` 인덱스 스캔 결과 → **두 결과를 병합** (index merge)
- WHERE 절에서 OR로 여러 조건을 묶으면, 일부만 인덱스를 타고 나머지는 Full Scan 할 수 있음
- 각 조건에 별도 인덱스가 있어도 효율성 저하
    - 여러 인덱스 중 무엇을 사용해야 할지 판단하기 어렵기 때문에 Full Table Scan 선택하는 경우 많음
    - (index merge 비용 문제
        - 인덱스를 각각 탐색하고, 결과를 병합해야 하므로 **랜덤 I/O가 많아지고 성능 저하**가 발생
- `UNION`으로 분리하여 각각 인덱스 사용을 유도하는 것이 해결책이 될 수 있음
    - 옵티마이저가 각 조건에 대해 **최적 인덱스 선택** 가능.
- IN 조건으로 리팩토링 가능 여부 확인도 해보면 좋음
    - 단일 인덱스로 효율적으로 탐색 가능
    - but 같은 컬럼인 경우만 가능
    - ex : `WHERE A IN (1, 2, 3)`

<br>

**복합 인덱스 컬럼 순서 위배**

- 복합 인덱스에서 선두 컬럼이 `WHERE` 절에 포함되지 않으면 인덱스 효과를 볼 수 없음
- ex
    - **인덱스**: (`name, age)`
    - `❌` **나쁜 예**: `WHERE age = 30`
    - `✅` **좋은 예**: `WHERE name = '홍길동'`
    - `✅` **좋은 예**: `WHERE name = '홍길동' AND age = 30`

<br>

**범위 조건 이후 컬럼**

- 복합 인덱스에서 `<, >, BETWEEN` 같은 **범위 조건**이 사용되면 그 뒤 컬럼은 인덱스 활용 불가.
- 복합 인덱스는 앞쪽 컬럼이 확정되어야 뒤쪽 컬럼을 빠르게 찾을 수 있음.
- 범위 조건은 **결과 집합이 여러 개라** 뒤쪽 컬럼이 정렬된 상태를 보장하지 않음.
- ex
    - 인덱스 :`(user_id, created_at, status)`
    - `❌` **나쁜 예**: `WHERE user_id = 100 AND created_at > '2025-09-01' AND status = 'COMPLETE';`
    - created_at까지만 인덱스 사용, status는 사용 불가
    
<br>

**검색할 데이터가 전체 데이터의 20~25% 이상인 경우 (데이터 카디널리티 너무 낮은 경우)**

- 카디널리티가 낮다면 인덱스를 써도 거의 모든 행을 읽게 됨
- 결과 데이터가 많다면
    - 인덱스 통해 데이터 찾고 디스크의 여러 위치에 흩어져 있는 데이터에 접근하는 랜덤 I/O 반복해야 함
    - 옵티마이저가 차라리 테이블 전체를 순차적으로 한 번에 읽는 시퀀셜 I/O가 더 빠르다고 판단
    - 따라서 인덱스를 사용하지 않을 수 있음
