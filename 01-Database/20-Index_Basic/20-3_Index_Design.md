# Index 설계

## 목차
- [Index 설계](#index-설계)
  - [목차](#목차)
    - [Index 생성 시점 및 방법](#index-생성-시점-및-방법)
    - [어떤 컬럼에 Index?](#어떤-컬럼에-index)
    - [복합 Index 컬럼 순서](#복합-index-컬럼-순서)

<br>

### Index 생성 시점 및 방법

- 초기 설계 단계
    - 테이블 설계 시 PRIMARY KEY, UNIQUE 제약과 함께 생성
    - PK/FK 인덱스는 반드시 고려.
    - 예상되는 주요 쿼리 패턴 기반으로 생성
- 운영 중
    - 실제 쿼리 패턴 분석 후 필요한 인덱스 추가
    - 성능 이슈 발생 후 실행 계획 분석 및 성능 모니터링 결과 바탕으로 추가 인덱스 설계.
    - 트래픽이 적은 시간대에 생성 권장
        - CREATE INDEX 명령어는 작업이 끝날 때까지 해당 테이블에 Write Lock 검.
        - 즉, 인덱스가 생성되는 동안 해당 테이블에 `INSERT`, `UPDATE`, `DELETE` 작업이 불가능
        - 대용량 테이블은 작업 시간이 매우 길기 때문에 이는 곧 **서비스 장애**로 이어짐.
- 대용량 데이터 처리 시
    - 인덱스 생성은 테이블의 모든 데이터 읽고, 정렬하고, 인덱스 구조 디스크에 쓰는 매우 무거운 작업
    - 이 과정에서 **CPU, 메모리, 디스크 I/O** 자원 엄청나게 소모하여 데이터베이스 서버 전체의 성능 저하
    - 대량 INSERT 작업 전 인덱스 삭제 후 작업 완료 후 재생성
        - 인덱스가 있는 상태에서 데이터 INSERT 시 업데이트 작업을 수백만 번 반복하는 것과 같음
        - 따라서 인덱스 먼저 삭제 후 데이터 그냥 INSERT
        - INSERT 후 한번에 인덱스 만드는 것이 더 효율적

<br>

### 어떤 컬럼에 Index?

인덱스는 한 테이블당 보통 3~5개 정도가 적당 

테이블의 목적에 따라 개수는 달라질 수 있음

<br>

인덱스를 설정할 컬럼을 선정할 때는 다음 기준을 활용

<br>

**카디널리티가 높은 컬럼**

- 한 컬럼이 갖고 있는 값의 중복 정도가 낮을수록 좋음
    - 카디널리티 높다고 중복도 낮다면 어떤 값으로 검색하든 거의 일정한 성능으로 소수의 행 찾아냄
    - 카디널리티 낮고 중복도 높다면  인덱스를 사용해도 데이터를 충분히 좁히지 못함

<br>

**활용도가 높은 컬럼**

- 해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값
- 인덱스 생성, 유지, 저장 모두 비용이 발생
- 많이 안 쓰는 컬럼에 인덱스 걸면 이득은 거의 없고, 오히려 관리, 성능 비용만 커짐.
- 활용도 높은 컬럼은 아래와 같음
    - WHERE, JOIN (FK), ORDER BY, GROUP BY절에 사용되는 컬럼
    - 자주 조회, 검색되는 컬럼

<br>

**INSERT, UPDATE, DELETE 자주 발생하지 않는 컬럼**

- 인덱스는 데이터를 변경할 때마다 같이 갱신되어야 함.
- 변경이 많으면 인덱스 유지 비용이 커지고 성능 저하 발생.
- **변경이 자주 없는 컬럼**에 인덱스를 걸어야 인덱스 유지 부담이 줄고, 읽기 성능을 안정적으로 확보

<br>

**Primary key**

- PK는 자주 조회/조인/참조되므로 인덱스 효율이 높음.
- 또한 FK 관계에서 참조 무결성 검증 시 빠른 탐색이 필요하므로 PK 인덱스는 필수.

<br>

**되도록 작은 데이터 타입** 

- 인덱스는 실제 데이터를 키 값과 함께 저장하므로, 키 크기가 크면 인덱스 전체 크기도 커짐.
- 인덱스가 커질수록 디스크 I/O, 메모리 캐싱 효율이 떨어짐 → 성능 저하.
- 작은 데이터 타입일수록 인덱스 트리의 깊이가 얕아지고 검색 속도 향상.

<br>

### 복합 Index 컬럼 순서

- **정의**
    - 복합 인덱스는 2개 이상의 컬럼을 조합하여 생성한 인덱스
    - MySQL은 인덱스에 최대 15개 컬럼까지 구성 가능
- **컬럼 순서**
    - 복합 인덱스 설계에서 **인덱스를 구성하는 속성들의 순서가 매우 중요**
    - 복합 인덱스 (A, B)를 설정했다면 A가 1순위, B가 2순위 정렬 조건이 됨
    - 복합 인덱스 B-Tree 구조상 첫번째로 지정된 인덱스 컬럼이 WHERE절 조건에 포함되어야 정상 동작
    - ex : (A, B) 순서로 복합 인덱스가 생성됨
        - 인덱스는 `A` 컬럼을 기준으로 먼저 정렬됨
        - `A` 값이 같은 데이터 내에서 `B` 컬럼을 기준으로 다시 정렬
        - 따라서 `WHERE A =?` 또는 `WHERE A =? AND B =?`와 같은 쿼리는 인덱스 효율적으로 사용 가능
        - `WHERE B =?` 쿼리는 인덱스의 선행 컬럼(`A`) 조건이 없으므로 인덱스를 제대로 활용하지 못함

```sql
CREATE INDEX index_name
ON table_name (A, B);

SELECT * FROM table_name WHERE A=1;             (o)
SELECT * FROM table_name WHERE A=1 AND B=2;     (o)
SELECT * FROM table_name WHERE B=2;             (x)
```

<br>

- **컬럼 순서 배치 방법**
    - 선두 컬럼 우선 전략:
        - 복합 인덱스는 선두 컬럼부터 순서대로 조건에 포함되어야 효과적으로 작동
        - (A, B, C) 인덱스에서 A, AB, ABC 조합만 효율적 활용 가능
    - = 조건으로 자주 조회하는 컬럼을 앞쪽에 배치:
        - `WHERE`절에서 `=` 연산자에  자주사용되는 컬럼을 가장 앞 순서에 배치하는 것이 기본 원칙
        - 
        - 이를 통해 탐색 시작점을 명확히 특정하여 검색 범위를 크게 줄일 수 있음
        - 범위 조건 (>, <) 같은 것 말고 = 조건
    - 카디널리티가 높은 컬럼을 앞쪽에 배치:
        - 다중 인덱스 생성 시 카디널리티가 높은 순서로 컬럼을 배치하는 것이 좋음
        - 데이터를 점진적으로 더 효과적으로 필터링해 나가는 것이 좋음
    - 쿼리 패턴 고려
        - 자주 함께 사용되는 컬럼들을 하나의 복합 인덱스로 구성
        - WHERE 절에서 사용되는 순서와 일치시키는 것이 유리
    - 정렬 고려
        - ORDER BY나 GROUP BY에 사용되는 컬럼 순서 고려
        - 정렬 작업을 생략할 수 있도록 인덱스 순서 설계
