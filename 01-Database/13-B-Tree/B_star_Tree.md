# B*Tree

## 💡 핵심 요약

<aside>
- **한 줄 정의:** B-Tree의 **저장 공간 효율을 극대화** 하기 위해 노드의 최소 점유율을 **2/3**로 높인 변형 자료구조.
- **핵심 키워드:** `B-Tree`, `저장공간효율`, `재분배(Redistribution)`, `M*2/3분할(2-3 Split)`
- **왜 중요한가?:** 노드 분할을 줄여 **트리 높이를 낮게 유지**하고, 디스크 I/O 성능을 개선하여 대규모 데이터 검색을 효율적으로 수행할 수 있습니다.
</aside>

# 1. 개념

B*Tree는 B-Tree의 변형으로, **균형 잡힌 트리 자료구조**로 설계되어 검색, 삽입, 삭제를 효율적으로 수행합니다. B-Tree와 유사하지만, 노드의 최소 키 개수를 2/3 차수(2M/3)로 유지하고, 노드 분할 시 이웃 노드와 키를 재분배하여 공간 활용도를 높이는 것이 특징입니다.

- **주요 차이점 (B-Tree와 비교)** :
    - **노드 최소 키 개수**: B-Tree는 최소 M/2개의 키를 유지하며, B*Tree는 2M/3개를 유지하여 노드 활용도가 높음.
    - **분할 전략**: B*Tree는 노드가 가득 차면 즉시 분할하지 않고, 이웃 노드와 키를 재분배하여 분할을 지연시킴.
    - 데이터는 모든 노드(리프 및 내부 노드)에 저장 가능(리프 노드 전용 아님, B+Tree와 다름).

---

# 2. 왜 필요한가? / 등장 배경 (Why is it needed?)

B-Tree는 검색과 삽입/삭제에 효율적이지만, 노드의 공간 활용도가 낮아질 수 있습니다(최소 50%만 채워짐). B*Tree는 이 문제를 해결하기 위해 개발되었습니다.

- **문제**
    - B-Tree의 노드는 **최소 50%만** 채워져 있어, 디스크 공간 낭비 가능.
    - 잦은 노드 분할은 디스크 쓰기 비용을 증가시킴.
    - 디스크 기반 시스템에서 저장 효율성과 I/O 성능이 중요.
- **해결**
    - B*Tree는 노드의 **최소 키 개수를 2M/3로 유지**, 평균 2/3 이상 채워져 공간 효율성 증가.
    - 노드 분할을 지연시키고 형제 노드와 키를 재분배하여 디스크 쓰기 감소.

---

# 3. 동작 원리 및 주요 특징 (How does it work?)

- **루트 및 내부 노드**
    
    키와 데이터(또는 데이터 포인터)를 저장, 자식 노드로의 탐색 경로 제공.
    
- **리프 노드**
    
    키와 데이터 저장, B+Tree와 달리 연결 리스트 구조 없음.
    
- **차수(M) → 높은 노드 활용도**
    
    노드의 최대 키 수는 M-1, **최소 키 수는 ⌈2M/3⌉-1.**
    
- **형제 노드로의 재분배(지연 분할)**
    
    인접한 **형제 노드(sibling)에 여유 공간이 있는지 확인**하여 키를 넘겨주는 **재분배 과정**을 시도합니다. 이를 통해 불필요한 노드 분할을 최소화합니다.
    
- **2-3 분할 (2-to-3 Split)**
    
    재분배를 시도했으나 형제 노드까지 가득 차 있다면, 그때 비로소 분할을 수행합니다.
    
    B-Tree가 1개의 꽉 찬 노드를 2개로 나누는 것과 달리, B*Tree는 **꽉 찬 2개의 노드(기존 노드 + 형제 노드)를 합쳐서 새로운 3개의 노드로 분할**합니다.
    
    > 📦 [꽉 찬 노드] + [꽉 찬 형제 노드]  →  [새 노드1] [새 노드2] [새 노드3]

| 특성 | B-Tree | B*Tree |
| --- | --- | --- |
| 최소 키 개수 | ⌈M/2⌉-1 | ⌈2M/3⌉-1 |
| 노드 활용도 | 최소 50% | 최소 66.7% |
| 분할 전략 | 즉시 분할 | 형제 재분배 후 2-3 분할 |
| 검색 복잡도 | O(log n) | O(log n) |
| 디스크 I/O 효율성 | 보통 | 높음 (더 적은 노드) |

---

# 4. 장점과 단점

### 👍 장점 (Advantages)

- **높은 공간 효율성**: 노드 최소 키 개수가 2M/3로, B-Tree보다 더 많은 키를 저장하여 디스크 공간 절약할 수 있습니다.
- **적은 노드 분할**: 형제 노드와 키 재분배로 분할 빈도 감소, 쓰기 성능 개선.
- **더 낮은 트리 높이**: 낮은 트리 높이로 인해 검색 속도 빠름(O(log n)).
- **디스크 I/O 최적화**: 더 많은 키를 노드에 저장하여 디스크 읽기/쓰기 횟수 감소.

### 👎 단점 (Disadvantages)

- **복잡한 구현**: 키 재분배와 2-3 분할 로직이 B-Tree보다 복잡.
- **범위 검색 비효율**: B+Tree와 달리 리프 노드 연결 리스트 없음, 범위 검색에서 비효율적.
- **낮은 실용성**: B+Tree가 데이터베이스에서 표준으로 사용됩니다. 복잡한 로직과 범위 검색에서 B+Tree보다 저하된 성능을 가지기 때문인데요, 덕분에 최근에는 거의 사용되지 않습니다.

---

# 5. 언제 사용해야 할까? (Use Cases)

### ✅ 사용하면 좋은 경우

- **저장 공간이 제한적인 환경**: 노드 활용도가 높아 디스크 공간 절약이 중요한 경우(예: 임베디드 시스템의 파일 시스템).
- **쓰기 작업이 빈번한 경우**: 키 재분배로 분할 빈도를 줄여 쓰기 성능 개선.
- **파일 시스템**: 예: ReiserFS와 같은 파일 시스템에서 메타데이터 관리.
- **카디널리티가 높은 데이터**: 고유 값이 많은 키(예: 파일 경로 해시).

### ❌ 사용을 고려해야 할 경우

- **범위 검색이 빈번한 경우**: B+Tree가 연결 리스트 구조로 더 효율적.
- **현대 데이터베이스**: MySQL, PostgreSQL 등은 B+Tree를 표준으로 사용.
- **소규모 데이터**: Full Table Scan이 더 빠른 경우(예: 1000행 이하).

---

# 🤔 Q&A 및 심화 질문

- **왜 2/3 노드 활용도를 사용하는가?**
    
    2/3(66.7%) 활용도는 공간 효율성과 분할 빈도 간의 균형을 제공. 50%보다 높은 활용도로 디스크 공간 절약, 100%는 분할을 너무 자주 유발.
    
- **키 재분배는 어떻게 이루어지는가?**
    
    가득 찬 노드는 이웃 노드와 키를 나누어 양쪽 모두 최소 2M/3을 유지. 불가능 시, 두 노드를 세 노드로 분할(2-3 split).
    
- **B*Tree는 데이터베이스에서 왜 덜 사용되는가?**
    
    B+Tree의 범위 검색 최적화와 단순한 구조가 현대 데이터베이스에 더 적합. B*Tree는 파일 시스템 등 특정 용도에 주로 사용.
    
- **B*Tree의 분할이 B-Tree보다 나은 점은?**
    
    2-3 분할과 키 재분배로 노드 활용도를 높이고, 분할 빈도를 줄여 디스크 쓰기 비용 감소.
    

---

# 🔗 연관 개념 (Related Concepts)

- `[[자료구조 - B-Tree]]` : B*Tree의 기반 자료구조.
- `[[자료구조 - B+Tree]]` : 범위 검색에 최적화된 B-Tree 변형.

---
