# 인덱스의 종류

# **1. Primary vs Secondary**

## Primary Index(기본 인덱스)

- **정의:** 테이블의 기본 키(Primary Key) 제약조건에 대해 생성되는 인덱스입니다.
- **특징:**
    - 행의 고유성을 보장하며, `NULL` 값을 허용하지 않습니다.
    - 테이블당 하나만 존재할 수 있습니다.
    - MySQL의 InnoDB 스토리지 엔진에서는 Primary Index가 항상 클러스터형 인덱스로 생성되어, 해당 인덱스 키의 순서대로 데이터가 물리적으로 정렬됩니다.

## Secondary Index(보조 인덱스)

- **정의:** 기본 키 이외의 컬럼에 대해 생성하는 모든 인덱스입니다.
- **특징:**
    - 특정 조건(`WHERE`)의 검색 속도를 향상시키기 위해 생성됩니다.
    - 기본적으로 값의 중복을 허용합니다. (`UNIQUE` 옵션 추가 시 중복 불가)
    - 테이블당 여러 개를 생성할 수 있습니다.
    - InnoDB 엔진에서 보조 인덱스는 비클러스터형 인덱스이며, 데이터 레코드의 물리적 주소 대신 Primary Key 값을 포인터로 가집니다.

---

# **2. Cluster vs Non-Cluster**

## **클러스터형 인덱스 (Clustered Index)**

- **정의:** 인덱스의 키 값 순서에 따라 테이블의 **데이터 행이 물리적으로 디스크에 정렬되어 저장되는 인덱스**입니다.
- **특징**
    - 테이블당 하나만 존재
    - **인덱스의 리프 노드가 곧 데이터 페이지**이므로, 키 값으로 검색 시 데이터 접근에 **추가적인 I/O가 발생하지 않아** 매우 빠름
    - 범위 검색(Range Scan)에서 뛰어난 성능
    - MySQL InnoDB에서는 Primary Key가 클러스터형 인덱스로 지정

## **비클러스터형 인덱스 (Non-Clustered Index)**

- **정의:** 데이터 행의 **물리적 순서와는 무관**하게, **별도의 공간에 인덱스 페이지를 생성**하여 정렬하는 방식입니다.
- **특징**
    - 테이블당 여러 개를 생성 가능
    - 인덱스의 리프 노드는 실제 데이터 행의 위치를 가리키는 포인터(주소값)를 가짐
    - 데이터를 찾기 위해 인덱스에서 포인터를 먼저 찾고, 그 포인터를 통해 실제 데이터에 접근하므로 최소 2번의 탐색이  필요 (단, 커버링 인덱스의 경우는 예외)
- 예시
    - 책 맨 뒤의 색인

### 비교

| **구분** | **Clustered Index** | **non-clustered Index** |
| --- | --- | --- |
| **개수** | **테이블당 1개** | **테이블당 여러 개** |
| **생성** | **자동 생성** | **수동 생성(Unique 제약조건 적용시 자동 생성)** |
| **NULL** | **허용 안함** | **허용 (조건부)** |
| **중복** | **허용 안함** | **허용 (조건부)** |
| **고유성** | **Unique && NOT NULL** | **Unique/Non-Unique가능** |
| **용도** | **데이터 고유 식별** | **검색 성능 향상** |

---

# **3. Column vs multi Column**

## **단일 컬럼 인덱스 (Single-Column Index)**

- **정의:** 하나의 컬럼으로만 구성된 인덱스입니다.
- **특징**
    - 단일 열의 값을 기반으로 빠른 검색을 지원
    - 특정 열에 대한 검색, 필터링이 빈번할 때 사용

## **복합 컬럼 인덱스 (Composite / Multi-Column Index)**

- **정의:** 두 개 이상의 컬럼을 조합하여 생성한 인덱스입니다.
- **특징**
    - 인덱스에 포함된 컬럼(열)의 순서가 매우 중요합니다. 인덱스는 정의된 컬럼 순서대로 정렬 (예: `(col1, col2)` 인덱스는 `col1`으로 먼저 정렬 후, `col1` 값이 같으면 `col2`로 정렬)
    - **인덱스 왼쪽 접두사 원칙(Left-Prefix Rule)**에 따라, 쿼리 조건에 인덱스의 첫 번째 컬럼부터 순서대로 사용되어야 효율적으로 동작

---

# **4. Unique Index**

- **정의:** 인덱스에 포함된 컬럼의 값이 테이블 내에서 **항상 고유(중복을 허용하지 않음)** 해야 한다는 제약 조건을 가진 인덱스입니다.
- **특징**
    - 데이터의 무결성을 보장하는 동시에, 해당 컬럼의 검색 속도를 높임
    - Primary Key와 달리 `NULL` 값을 허용하며, 여러 개의 `NULL` 값이 저장될 수 있음
    - 테이블당 여러 개의 Unique 인덱스를 생성할 수 있음

---

# **5. Index 종류 비교**

| **인덱스 종류** | **특징** | **주요 용도** | **장점** | **단점** |
| --- | --- | --- | --- | --- |
| **Primary Index** | 기본 키에 생성, 고유성 보장 | 기본 키 검색, 무결성 유지 | 빠른 검색, 무결성 보장 | 쓰기 작업 시 비용 발생 |
| **Secondary Index** | 기본 키 외 열에 생성, 중복 허용 | 추가적인 검색 최적화 | 유연한 검색 가능 | 추가 저장 공간, 쓰기 성능 저하 |
| **Cluster Index** | 데이터 물리적 정렬 | 범위 검색, 정렬 | 빠른 검색, 효율적 데이터 접근 | 쓰기 작업 시 재정렬 비용 |
| **Non-Cluster Index** | 데이터와 별도의 인덱스 구조 | 특정 열 검색 | 유연성, 다중 인덱스 가능 | 추가 I/O 및 저장 공간 필요 |
| **Column Index** | 단일 열에 생성 | 단일 열 조건 검색 | 간단, 특정 열 검색 최적화 | 복합 조건에서 효율 낮음 |
| **Multi-Column Index** | 다중 열 조합 | 다중 열 조건 검색 | 복합 조건 검색 최적화 | 열 순서 민감, 저장 공간 증가 |
| **Unique Index** | 고유성 제약 | 고유 값 검색, 무결성 유지 | 데이터 무결성, 빠른 검색 | 고유성 검증으로 쓰기 성능 저하 |

---

# 6. 함수/표현식 기반 인덱스(Function/Expression-Based Index)

- **정의:** 컬럼의 원본 값이 아닌, 특정 함수나 표현식을 적용한 결과 값을 인덱싱하는 방식입니다. (MySQL 8.0부터 지원)
- **목적:** `WHERE` 절에서 `LOWER(email) = '...'` 나 `WHERE YEAR(created_at) = 2025` 와 같이 함수를 사용한 조건으로 검색할 때, 인덱스가 동작하도록 하여 성능을 향상시킵니다.
- **특징**
    - 복잡한 조건 검색 최적화 가능
    - 함수 표현식이 포함된 쿼리 성능이 크게 향상됨
    - InnoDB에서는 가상 열을 사용해서 구현

---

# 7. 커버링 인덱스(Covering Index)

- **정의:** 별도의 인덱스 종류가 아닌, **인덱스를 활용하는 최적화** 기법입니다. 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 있어, 실제 테이블 데이터에 접근할 필요 없이 **인덱스만으로 결과를 반환하는 경우**를 말합니다.
- **목적:** 테이블 데이터로의 추가적인 디스크 I/O를 완전히 제거하여 쿼리 성능을 극대화합니다. `EXPLAIN` 실행 계획의 `Extra` 필드에 `Using index`로 표시됩니다.
- **특징**
    - 주로 Non-Clustered Index로 구현됨
    - 물리적 접근이 없어서 I/O 비용이 대폭 감소
    - InnoDB에서는 복합 인덱스로 구현

---

# 8. 부분 인덱스(Partial Index)

- **정의:** 테이블의 모든 행이 아닌, 특정 조건을 만족하는 **일부 행만 선택하여 생성하는 인덱스**입니다.(WHERE절을 사용해 인덱스 대상을 제한함)
- **목적:** 인덱스의 크기를 줄여 저장 공간을 절약하고, 관리 비용을 낮추며, 타겟 쿼리의 성능을 향상시킵니다.
- **MySQL의 구현:** MySQL은 `CREATE INDEX ... WHERE ...` 구문을 직접 지원하지 않습니다. 대신, **파티셔닝**을 통해 유사한 효과를 구현할 수 있습니다. 특정 파티션만 스캔하는 쿼리는 결과적으로 데이터의 일부만 접근하게 됩니다.

---

# 9. 전문 검색 인덱스(Full-Text Index)

- **정의:** 자연어 텍스트(문장, 문단) 내의 **단어나 구문을 빠르게 검색**하기 위해 설계된 특수 인덱스입니다.
- **특징:**
    - 데이터의 하위 집합만 자주 검색할 때 사용합니다.
        - 인덱스 크기 감소, 특정 쿼리에서 성능 향상
    - InnoDB에서는 자연어 및 Boolean 검색이 가능합니다.
    - 불용어(stopword) 처리, 어간 추출(stemming) 등 텍스트 검색에 특화된 기능을 제공합니다.
    - `LIKE '%word%'` 와 비교하여 훨씬 빠르고 정교한 검색이 가능합니다.
    - `MATCH() ... AGAINST()` 구문을 사용하여 쿼리를 실행합니다.
